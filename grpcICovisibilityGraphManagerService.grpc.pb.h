// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: grpcICovisibilityGraphManagerService.proto
#ifndef GRPC_grpcICovisibilityGraphManagerService_2eproto__INCLUDED
#define GRPC_grpcICovisibilityGraphManagerService_2eproto__INCLUDED

#include "grpcICovisibilityGraphManagerService.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpcICovisibilityGraphManager {

class grpcICovisibilityGraphManagerService final {
 public:
  static constexpr char const* service_full_name() {
    return "grpcICovisibilityGraphManager.grpcICovisibilityGraphManagerService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>> AsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>>(AsyncincreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>> PrepareAsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>>(PrepareAsyncincreaseEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>> AsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>>(AsyncdecreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>> PrepareAsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>>(PrepareAsyncdecreaseEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>> AsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>>(AsyncremoveEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>> PrepareAsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>>(PrepareAsyncremoveEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpcICovisibilityGraphManager::getEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>> AsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>>(AsyncgetEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>> PrepareAsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>>(PrepareAsyncgetEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpcICovisibilityGraphManager::isEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>> AsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>>(AsyncisEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>> PrepareAsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>>(PrepareAsyncisEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>> AsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>>(AsyncgetAllNodesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>> PrepareAsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>>(PrepareAsyncgetAllNodesRaw(context, request, cq));
    }
    virtual ::grpc::Status suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>> AsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>>(AsyncsuppressNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>> PrepareAsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>>(PrepareAsyncsuppressNodeRaw(context, request, cq));
    }
    virtual ::grpc::Status getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>> AsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>>(AsyncgetNeighborsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>> PrepareAsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>>(PrepareAsyncgetNeighborsRaw(context, request, cq));
    }
    virtual ::grpc::Status minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>> AsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>>(AsyncminimalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>> PrepareAsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>>(PrepareAsyncminimalSpanningTreeRaw(context, request, cq));
    }
    virtual ::grpc::Status maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>> AsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>>(AsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>> PrepareAsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>>(PrepareAsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    virtual ::grpc::Status getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>> AsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>>(AsyncgetShortestPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>> PrepareAsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>>(PrepareAsyncgetShortestPathRaw(context, request, cq));
    }
    virtual ::grpc::Status display(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest& request, ::grpcICovisibilityGraphManager::displayResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>> Asyncdisplay(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>>(AsyncdisplayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>> PrepareAsyncdisplay(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>>(PrepareAsyncdisplayRaw(context, request, cq));
    }
    virtual ::grpc::Status saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpcICovisibilityGraphManager::saveToFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>> AsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>>(AsyncsaveToFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>> PrepareAsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>>(PrepareAsyncsaveToFileRaw(context, request, cq));
    }
    virtual ::grpc::Status loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>> AsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>>(AsyncloadFromFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>> PrepareAsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>>(PrepareAsyncloadFromFileRaw(context, request, cq));
    }
    virtual ::grpc::Status getConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest& request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>> AsyncgetConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>>(AsyncgetConstCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>> PrepareAsyncgetConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>>(PrepareAsyncgetConstCovisibilityGraphRaw(context, request, cq));
    }
    virtual ::grpc::Status getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>> AsyncgetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>>(AsyncgetCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>> PrepareAsyncgetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>>(PrepareAsyncgetCovisibilityGraphRaw(context, request, cq));
    }
    virtual ::grpc::Status setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetCovisibilityGraphRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void display(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest* request, ::grpcICovisibilityGraphManager::displayResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void display(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest* request, ::grpcICovisibilityGraphManager::displayResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void display(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest* request, ::grpcICovisibilityGraphManager::displayResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>* AsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>* PrepareAsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* AsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* PrepareAsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>* AsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>* PrepareAsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>* AsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>* PrepareAsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>* AsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>* PrepareAsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>* AsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>* PrepareAsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>* AsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>* PrepareAsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>* AsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>* PrepareAsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* AsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* PrepareAsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* AsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* PrepareAsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>* AsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>* PrepareAsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>* AsyncdisplayRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>* PrepareAsyncdisplayRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>* AsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>* PrepareAsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>* AsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>* PrepareAsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* AsyncgetConstCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* PrepareAsyncgetConstCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* AsyncgetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* PrepareAsyncgetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>> AsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>>(AsyncincreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>> PrepareAsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>>(PrepareAsyncincreaseEdgeRaw(context, request, cq));
    }
    ::grpc::Status decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>> AsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>>(AsyncdecreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>> PrepareAsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>>(PrepareAsyncdecreaseEdgeRaw(context, request, cq));
    }
    ::grpc::Status removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>> AsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>>(AsyncremoveEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>> PrepareAsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>>(PrepareAsyncremoveEdgeRaw(context, request, cq));
    }
    ::grpc::Status getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpcICovisibilityGraphManager::getEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>> AsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>>(AsyncgetEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>> PrepareAsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>>(PrepareAsyncgetEdgeRaw(context, request, cq));
    }
    ::grpc::Status isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpcICovisibilityGraphManager::isEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>> AsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>>(AsyncisEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>> PrepareAsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>>(PrepareAsyncisEdgeRaw(context, request, cq));
    }
    ::grpc::Status getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>> AsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>>(AsyncgetAllNodesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>> PrepareAsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>>(PrepareAsyncgetAllNodesRaw(context, request, cq));
    }
    ::grpc::Status suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>> AsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>>(AsyncsuppressNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>> PrepareAsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>>(PrepareAsyncsuppressNodeRaw(context, request, cq));
    }
    ::grpc::Status getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>> AsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>>(AsyncgetNeighborsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>> PrepareAsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>>(PrepareAsyncgetNeighborsRaw(context, request, cq));
    }
    ::grpc::Status minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>> AsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>>(AsyncminimalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>> PrepareAsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>>(PrepareAsyncminimalSpanningTreeRaw(context, request, cq));
    }
    ::grpc::Status maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>> AsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>>(AsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>> PrepareAsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>>(PrepareAsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    ::grpc::Status getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>> AsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>>(AsyncgetShortestPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>> PrepareAsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>>(PrepareAsyncgetShortestPathRaw(context, request, cq));
    }
    ::grpc::Status display(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest& request, ::grpcICovisibilityGraphManager::displayResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>> Asyncdisplay(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>>(AsyncdisplayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>> PrepareAsyncdisplay(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>>(PrepareAsyncdisplayRaw(context, request, cq));
    }
    ::grpc::Status saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpcICovisibilityGraphManager::saveToFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>> AsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>>(AsyncsaveToFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>> PrepareAsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>>(PrepareAsyncsaveToFileRaw(context, request, cq));
    }
    ::grpc::Status loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>> AsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>>(AsyncloadFromFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>> PrepareAsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>>(PrepareAsyncloadFromFileRaw(context, request, cq));
    }
    ::grpc::Status getConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest& request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>> AsyncgetConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>>(AsyncgetConstCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>> PrepareAsyncgetConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>>(PrepareAsyncgetConstCovisibilityGraphRaw(context, request, cq));
    }
    ::grpc::Status getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>> AsyncgetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>>(AsyncgetCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>> PrepareAsyncgetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>>(PrepareAsyncgetCovisibilityGraphRaw(context, request, cq));
    }
    ::grpc::Status setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetCovisibilityGraphRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void display(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest* request, ::grpcICovisibilityGraphManager::displayResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void display(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest* request, ::grpcICovisibilityGraphManager::displayResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void display(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest* request, ::grpcICovisibilityGraphManager::displayResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getConstCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>* AsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>* PrepareAsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* AsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* PrepareAsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>* AsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>* PrepareAsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>* AsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>* PrepareAsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>* AsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>* PrepareAsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>* AsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>* PrepareAsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>* AsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>* PrepareAsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>* AsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>* PrepareAsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* AsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* PrepareAsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* AsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* PrepareAsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>* AsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>* PrepareAsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>* AsyncdisplayRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>* PrepareAsyncdisplayRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::displayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>* AsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>* PrepareAsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>* AsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>* PrepareAsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* AsyncgetConstCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* PrepareAsyncgetConstCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* AsyncgetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* PrepareAsyncgetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_increaseEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_decreaseEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_removeEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_getEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_isEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_getAllNodes_;
    const ::grpc::internal::RpcMethod rpcmethod_suppressNode_;
    const ::grpc::internal::RpcMethod rpcmethod_getNeighbors_;
    const ::grpc::internal::RpcMethod rpcmethod_minimalSpanningTree_;
    const ::grpc::internal::RpcMethod rpcmethod_maximalSpanningTree_;
    const ::grpc::internal::RpcMethod rpcmethod_getShortestPath_;
    const ::grpc::internal::RpcMethod rpcmethod_display_;
    const ::grpc::internal::RpcMethod rpcmethod_saveToFile_;
    const ::grpc::internal::RpcMethod rpcmethod_loadFromFile_;
    const ::grpc::internal::RpcMethod rpcmethod_getConstCovisibilityGraph_;
    const ::grpc::internal::RpcMethod rpcmethod_getCovisibilityGraph_;
    const ::grpc::internal::RpcMethod rpcmethod_setCovisibilityGraph_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status increaseEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response);
    virtual ::grpc::Status decreaseEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response);
    virtual ::grpc::Status removeEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response);
    virtual ::grpc::Status getEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response);
    virtual ::grpc::Status isEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response);
    virtual ::grpc::Status getAllNodes(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response);
    virtual ::grpc::Status suppressNode(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response);
    virtual ::grpc::Status getNeighbors(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response);
    virtual ::grpc::Status minimalSpanningTree(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response);
    virtual ::grpc::Status maximalSpanningTree(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response);
    virtual ::grpc::Status getShortestPath(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response);
    virtual ::grpc::Status display(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::displayRequest* request, ::grpcICovisibilityGraphManager::displayResponse* response);
    virtual ::grpc::Status saveToFile(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response);
    virtual ::grpc::Status loadFromFile(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response);
    virtual ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response);
    virtual ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response);
    virtual ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_increaseEdge() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestincreaseEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::increaseEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdecreaseEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_removeEdge() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestremoveEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::removeEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getEdge() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isEdge() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::isEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getAllNodes() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAllNodes(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getAllNodesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_suppressNode() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsuppressNode(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::suppressNodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getNeighbors() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNeighbors(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getNeighborsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestminimalSpanningTree(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmaximalSpanningTree(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getShortestPath() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetShortestPath(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getShortestPathResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_display() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::displayRequest* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdisplay(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::displayRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::displayResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveToFile() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveToFile(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::saveToFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_loadFromFile() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestloadFromFile(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::loadFromFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getConstCovisibilityGraph() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetConstCovisibilityGraph(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getCovisibilityGraph() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetCovisibilityGraph(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setCovisibilityGraph() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetCovisibilityGraph(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_increaseEdge<WithAsyncMethod_decreaseEdge<WithAsyncMethod_removeEdge<WithAsyncMethod_getEdge<WithAsyncMethod_isEdge<WithAsyncMethod_getAllNodes<WithAsyncMethod_suppressNode<WithAsyncMethod_getNeighbors<WithAsyncMethod_minimalSpanningTree<WithAsyncMethod_maximalSpanningTree<WithAsyncMethod_getShortestPath<WithAsyncMethod_display<WithAsyncMethod_saveToFile<WithAsyncMethod_loadFromFile<WithAsyncMethod_getConstCovisibilityGraph<WithAsyncMethod_getCovisibilityGraph<WithAsyncMethod_setCovisibilityGraph<Service > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_increaseEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::increaseEdgeRequest, ::grpcICovisibilityGraphManager::increaseEdgeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response) { return this->increaseEdge(context, request, response); }));}
    void SetMessageAllocatorFor_increaseEdge(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::increaseEdgeRequest, ::grpcICovisibilityGraphManager::increaseEdgeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::increaseEdgeRequest, ::grpcICovisibilityGraphManager::increaseEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* increaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* increaseEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_decreaseEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::decreaseEdgeRequest, ::grpcICovisibilityGraphManager::decreaseEdgeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response) { return this->decreaseEdge(context, request, response); }));}
    void SetMessageAllocatorFor_decreaseEdge(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::decreaseEdgeRequest, ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::decreaseEdgeRequest, ::grpcICovisibilityGraphManager::decreaseEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* decreaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* decreaseEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_removeEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::removeEdgeRequest, ::grpcICovisibilityGraphManager::removeEdgeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response) { return this->removeEdge(context, request, response); }));}
    void SetMessageAllocatorFor_removeEdge(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::removeEdgeRequest, ::grpcICovisibilityGraphManager::removeEdgeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::removeEdgeRequest, ::grpcICovisibilityGraphManager::removeEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* removeEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* removeEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getEdgeRequest, ::grpcICovisibilityGraphManager::getEdgeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response) { return this->getEdge(context, request, response); }));}
    void SetMessageAllocatorFor_getEdge(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::getEdgeRequest, ::grpcICovisibilityGraphManager::getEdgeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getEdgeRequest, ::grpcICovisibilityGraphManager::getEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_isEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::isEdgeRequest, ::grpcICovisibilityGraphManager::isEdgeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response) { return this->isEdge(context, request, response); }));}
    void SetMessageAllocatorFor_isEdge(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::isEdgeRequest, ::grpcICovisibilityGraphManager::isEdgeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::isEdgeRequest, ::grpcICovisibilityGraphManager::isEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* isEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* isEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getAllNodes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getAllNodesRequest, ::grpcICovisibilityGraphManager::getAllNodesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response) { return this->getAllNodes(context, request, response); }));}
    void SetMessageAllocatorFor_getAllNodes(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::getAllNodesRequest, ::grpcICovisibilityGraphManager::getAllNodesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getAllNodesRequest, ::grpcICovisibilityGraphManager::getAllNodesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getAllNodes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getAllNodes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_suppressNode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::suppressNodeRequest, ::grpcICovisibilityGraphManager::suppressNodeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response) { return this->suppressNode(context, request, response); }));}
    void SetMessageAllocatorFor_suppressNode(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::suppressNodeRequest, ::grpcICovisibilityGraphManager::suppressNodeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::suppressNodeRequest, ::grpcICovisibilityGraphManager::suppressNodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* suppressNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* suppressNode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getNeighbors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getNeighborsRequest, ::grpcICovisibilityGraphManager::getNeighborsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response) { return this->getNeighbors(context, request, response); }));}
    void SetMessageAllocatorFor_getNeighbors(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::getNeighborsRequest, ::grpcICovisibilityGraphManager::getNeighborsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getNeighborsRequest, ::grpcICovisibilityGraphManager::getNeighborsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getNeighbors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getNeighbors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_minimalSpanningTree() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response) { return this->minimalSpanningTree(context, request, response); }));}
    void SetMessageAllocatorFor_minimalSpanningTree(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* minimalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* minimalSpanningTree(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_maximalSpanningTree() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response) { return this->maximalSpanningTree(context, request, response); }));}
    void SetMessageAllocatorFor_maximalSpanningTree(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* maximalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* maximalSpanningTree(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getShortestPath() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getShortestPathRequest, ::grpcICovisibilityGraphManager::getShortestPathResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response) { return this->getShortestPath(context, request, response); }));}
    void SetMessageAllocatorFor_getShortestPath(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::getShortestPathRequest, ::grpcICovisibilityGraphManager::getShortestPathResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getShortestPathRequest, ::grpcICovisibilityGraphManager::getShortestPathResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getShortestPath(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getShortestPath(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_display() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::displayRequest, ::grpcICovisibilityGraphManager::displayResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::displayRequest* request, ::grpcICovisibilityGraphManager::displayResponse* response) { return this->display(context, request, response); }));}
    void SetMessageAllocatorFor_display(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::displayRequest, ::grpcICovisibilityGraphManager::displayResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::displayRequest, ::grpcICovisibilityGraphManager::displayResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::displayRequest* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* display(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::displayRequest* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* display(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::displayRequest* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_saveToFile() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::saveToFileRequest, ::grpcICovisibilityGraphManager::saveToFileResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response) { return this->saveToFile(context, request, response); }));}
    void SetMessageAllocatorFor_saveToFile(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::saveToFileRequest, ::grpcICovisibilityGraphManager::saveToFileResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::saveToFileRequest, ::grpcICovisibilityGraphManager::saveToFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* saveToFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* saveToFile(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_loadFromFile() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::loadFromFileRequest, ::grpcICovisibilityGraphManager::loadFromFileResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response) { return this->loadFromFile(context, request, response); }));}
    void SetMessageAllocatorFor_loadFromFile(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::loadFromFileRequest, ::grpcICovisibilityGraphManager::loadFromFileResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::loadFromFileRequest, ::grpcICovisibilityGraphManager::loadFromFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* loadFromFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* loadFromFile(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getConstCovisibilityGraph() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response) { return this->getConstCovisibilityGraph(context, request, response); }));}
    void SetMessageAllocatorFor_getConstCovisibilityGraph(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getConstCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getConstCovisibilityGraph(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getCovisibilityGraph() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response) { return this->getCovisibilityGraph(context, request, response); }));}
    void SetMessageAllocatorFor_getCovisibilityGraph(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getCovisibilityGraph(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_setCovisibilityGraph() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response) { return this->setCovisibilityGraph(context, request, response); }));}
    void SetMessageAllocatorFor_setCovisibilityGraph(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setCovisibilityGraph(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_increaseEdge<ExperimentalWithCallbackMethod_decreaseEdge<ExperimentalWithCallbackMethod_removeEdge<ExperimentalWithCallbackMethod_getEdge<ExperimentalWithCallbackMethod_isEdge<ExperimentalWithCallbackMethod_getAllNodes<ExperimentalWithCallbackMethod_suppressNode<ExperimentalWithCallbackMethod_getNeighbors<ExperimentalWithCallbackMethod_minimalSpanningTree<ExperimentalWithCallbackMethod_maximalSpanningTree<ExperimentalWithCallbackMethod_getShortestPath<ExperimentalWithCallbackMethod_display<ExperimentalWithCallbackMethod_saveToFile<ExperimentalWithCallbackMethod_loadFromFile<ExperimentalWithCallbackMethod_getConstCovisibilityGraph<ExperimentalWithCallbackMethod_getCovisibilityGraph<ExperimentalWithCallbackMethod_setCovisibilityGraph<Service > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_increaseEdge<ExperimentalWithCallbackMethod_decreaseEdge<ExperimentalWithCallbackMethod_removeEdge<ExperimentalWithCallbackMethod_getEdge<ExperimentalWithCallbackMethod_isEdge<ExperimentalWithCallbackMethod_getAllNodes<ExperimentalWithCallbackMethod_suppressNode<ExperimentalWithCallbackMethod_getNeighbors<ExperimentalWithCallbackMethod_minimalSpanningTree<ExperimentalWithCallbackMethod_maximalSpanningTree<ExperimentalWithCallbackMethod_getShortestPath<ExperimentalWithCallbackMethod_display<ExperimentalWithCallbackMethod_saveToFile<ExperimentalWithCallbackMethod_loadFromFile<ExperimentalWithCallbackMethod_getConstCovisibilityGraph<ExperimentalWithCallbackMethod_getCovisibilityGraph<ExperimentalWithCallbackMethod_setCovisibilityGraph<Service > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_increaseEdge() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_removeEdge() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getEdge() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isEdge() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getAllNodes() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_suppressNode() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getNeighbors() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getShortestPath() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_display() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::displayRequest* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveToFile() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_loadFromFile() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getConstCovisibilityGraph() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getCovisibilityGraph() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setCovisibilityGraph() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_increaseEdge() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestincreaseEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdecreaseEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_removeEdge() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestremoveEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getEdge() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isEdge() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getAllNodes() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAllNodes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_suppressNode() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsuppressNode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getNeighbors() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNeighbors(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestminimalSpanningTree(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmaximalSpanningTree(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getShortestPath() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetShortestPath(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_display() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::displayRequest* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdisplay(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveToFile() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveToFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_loadFromFile() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestloadFromFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getConstCovisibilityGraph() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetConstCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getCovisibilityGraph() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setCovisibilityGraph() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_increaseEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->increaseEdge(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* increaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* increaseEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_decreaseEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->decreaseEdge(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* decreaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* decreaseEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_removeEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->removeEdge(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* removeEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* removeEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getEdge(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_isEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isEdge(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* isEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* isEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getAllNodes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getAllNodes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getAllNodes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getAllNodes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_suppressNode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->suppressNode(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* suppressNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* suppressNode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getNeighbors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getNeighbors(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getNeighbors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getNeighbors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_minimalSpanningTree() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->minimalSpanningTree(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* minimalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* minimalSpanningTree(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_maximalSpanningTree() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->maximalSpanningTree(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* maximalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* maximalSpanningTree(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getShortestPath() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getShortestPath(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getShortestPath(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getShortestPath(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_display() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->display(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::displayRequest* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* display(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* display(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_saveToFile() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveToFile(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* saveToFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* saveToFile(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_loadFromFile() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->loadFromFile(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* loadFromFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* loadFromFile(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getConstCovisibilityGraph() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getConstCovisibilityGraph(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getConstCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getConstCovisibilityGraph(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getCovisibilityGraph() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getCovisibilityGraph(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getCovisibilityGraph(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_setCovisibilityGraph() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setCovisibilityGraph(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* setCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* setCovisibilityGraph(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_increaseEdge() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::increaseEdgeRequest, ::grpcICovisibilityGraphManager::increaseEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::increaseEdgeRequest, ::grpcICovisibilityGraphManager::increaseEdgeResponse>* streamer) {
                       return this->StreamedincreaseEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedincreaseEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::increaseEdgeRequest,::grpcICovisibilityGraphManager::increaseEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::decreaseEdgeRequest, ::grpcICovisibilityGraphManager::decreaseEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::decreaseEdgeRequest, ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* streamer) {
                       return this->StreameddecreaseEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddecreaseEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::decreaseEdgeRequest,::grpcICovisibilityGraphManager::decreaseEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_removeEdge() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::removeEdgeRequest, ::grpcICovisibilityGraphManager::removeEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::removeEdgeRequest, ::grpcICovisibilityGraphManager::removeEdgeResponse>* streamer) {
                       return this->StreamedremoveEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedremoveEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::removeEdgeRequest,::grpcICovisibilityGraphManager::removeEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getEdge() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::getEdgeRequest, ::grpcICovisibilityGraphManager::getEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::getEdgeRequest, ::grpcICovisibilityGraphManager::getEdgeResponse>* streamer) {
                       return this->StreamedgetEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::getEdgeRequest,::grpcICovisibilityGraphManager::getEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isEdge() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::isEdgeRequest, ::grpcICovisibilityGraphManager::isEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::isEdgeRequest, ::grpcICovisibilityGraphManager::isEdgeResponse>* streamer) {
                       return this->StreamedisEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::isEdgeRequest,::grpcICovisibilityGraphManager::isEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getAllNodes() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::getAllNodesRequest, ::grpcICovisibilityGraphManager::getAllNodesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::getAllNodesRequest, ::grpcICovisibilityGraphManager::getAllNodesResponse>* streamer) {
                       return this->StreamedgetAllNodes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetAllNodes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::getAllNodesRequest,::grpcICovisibilityGraphManager::getAllNodesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_suppressNode() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::suppressNodeRequest, ::grpcICovisibilityGraphManager::suppressNodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::suppressNodeRequest, ::grpcICovisibilityGraphManager::suppressNodeResponse>* streamer) {
                       return this->StreamedsuppressNode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsuppressNode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::suppressNodeRequest,::grpcICovisibilityGraphManager::suppressNodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getNeighbors() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::getNeighborsRequest, ::grpcICovisibilityGraphManager::getNeighborsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::getNeighborsRequest, ::grpcICovisibilityGraphManager::getNeighborsResponse>* streamer) {
                       return this->StreamedgetNeighbors(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetNeighbors(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::getNeighborsRequest,::grpcICovisibilityGraphManager::getNeighborsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* streamer) {
                       return this->StreamedminimalSpanningTree(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedminimalSpanningTree(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest,::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* streamer) {
                       return this->StreamedmaximalSpanningTree(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmaximalSpanningTree(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest,::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getShortestPath() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::getShortestPathRequest, ::grpcICovisibilityGraphManager::getShortestPathResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::getShortestPathRequest, ::grpcICovisibilityGraphManager::getShortestPathResponse>* streamer) {
                       return this->StreamedgetShortestPath(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetShortestPath(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::getShortestPathRequest,::grpcICovisibilityGraphManager::getShortestPathResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_display() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::displayRequest, ::grpcICovisibilityGraphManager::displayResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::displayRequest, ::grpcICovisibilityGraphManager::displayResponse>* streamer) {
                       return this->Streameddisplay(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::displayRequest* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddisplay(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::displayRequest,::grpcICovisibilityGraphManager::displayResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveToFile() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::saveToFileRequest, ::grpcICovisibilityGraphManager::saveToFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::saveToFileRequest, ::grpcICovisibilityGraphManager::saveToFileResponse>* streamer) {
                       return this->StreamedsaveToFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveToFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::saveToFileRequest,::grpcICovisibilityGraphManager::saveToFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_loadFromFile() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::loadFromFileRequest, ::grpcICovisibilityGraphManager::loadFromFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::loadFromFileRequest, ::grpcICovisibilityGraphManager::loadFromFileResponse>* streamer) {
                       return this->StreamedloadFromFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedloadFromFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::loadFromFileRequest,::grpcICovisibilityGraphManager::loadFromFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getConstCovisibilityGraph() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* streamer) {
                       return this->StreamedgetConstCovisibilityGraph(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetConstCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphRequest,::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getCovisibilityGraph() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* streamer) {
                       return this->StreamedgetCovisibilityGraph(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest,::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setCovisibilityGraph() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetCovisibilityGraph(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_increaseEdge<WithStreamedUnaryMethod_decreaseEdge<WithStreamedUnaryMethod_removeEdge<WithStreamedUnaryMethod_getEdge<WithStreamedUnaryMethod_isEdge<WithStreamedUnaryMethod_getAllNodes<WithStreamedUnaryMethod_suppressNode<WithStreamedUnaryMethod_getNeighbors<WithStreamedUnaryMethod_minimalSpanningTree<WithStreamedUnaryMethod_maximalSpanningTree<WithStreamedUnaryMethod_getShortestPath<WithStreamedUnaryMethod_display<WithStreamedUnaryMethod_saveToFile<WithStreamedUnaryMethod_loadFromFile<WithStreamedUnaryMethod_getConstCovisibilityGraph<WithStreamedUnaryMethod_getCovisibilityGraph<WithStreamedUnaryMethod_setCovisibilityGraph<Service > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_increaseEdge<WithStreamedUnaryMethod_decreaseEdge<WithStreamedUnaryMethod_removeEdge<WithStreamedUnaryMethod_getEdge<WithStreamedUnaryMethod_isEdge<WithStreamedUnaryMethod_getAllNodes<WithStreamedUnaryMethod_suppressNode<WithStreamedUnaryMethod_getNeighbors<WithStreamedUnaryMethod_minimalSpanningTree<WithStreamedUnaryMethod_maximalSpanningTree<WithStreamedUnaryMethod_getShortestPath<WithStreamedUnaryMethod_display<WithStreamedUnaryMethod_saveToFile<WithStreamedUnaryMethod_loadFromFile<WithStreamedUnaryMethod_getConstCovisibilityGraph<WithStreamedUnaryMethod_getCovisibilityGraph<WithStreamedUnaryMethod_setCovisibilityGraph<Service > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace grpcICovisibilityGraphManager


#endif  // GRPC_grpcICovisibilityGraphManagerService_2eproto__INCLUDED
