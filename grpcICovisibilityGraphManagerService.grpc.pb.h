// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: grpcICovisibilityGraphManagerService.proto
#ifndef GRPC_grpcICovisibilityGraphManagerService_2eproto__INCLUDED
#define GRPC_grpcICovisibilityGraphManagerService_2eproto__INCLUDED

#include "grpcICovisibilityGraphManagerService.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpcICovisibilityGraphManager {

class grpcICovisibilityGraphManagerService final {
 public:
  static constexpr char const* service_full_name() {
    return "grpcICovisibilityGraphManager.grpcICovisibilityGraphManagerService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>> AsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>>(AsyncincreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>> PrepareAsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>>(PrepareAsyncincreaseEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>> AsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>>(AsyncdecreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>> PrepareAsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>>(PrepareAsyncdecreaseEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>> AsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>>(AsyncremoveEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>> PrepareAsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>>(PrepareAsyncremoveEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpcICovisibilityGraphManager::getEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>> AsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>>(AsyncgetEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>> PrepareAsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>>(PrepareAsyncgetEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpcICovisibilityGraphManager::isEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>> AsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>>(AsyncisEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>> PrepareAsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>>(PrepareAsyncisEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>> AsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>>(AsyncgetAllNodesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>> PrepareAsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>>(PrepareAsyncgetAllNodesRaw(context, request, cq));
    }
    virtual ::grpc::Status suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>> AsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>>(AsyncsuppressNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>> PrepareAsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>>(PrepareAsyncsuppressNodeRaw(context, request, cq));
    }
    virtual ::grpc::Status getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>> AsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>>(AsyncgetNeighborsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>> PrepareAsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>>(PrepareAsyncgetNeighborsRaw(context, request, cq));
    }
    virtual ::grpc::Status minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>> AsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>>(AsyncminimalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>> PrepareAsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>>(PrepareAsyncminimalSpanningTreeRaw(context, request, cq));
    }
    virtual ::grpc::Status maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>> AsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>>(AsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>> PrepareAsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>>(PrepareAsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    virtual ::grpc::Status getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>> AsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>>(AsyncgetShortestPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>> PrepareAsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>>(PrepareAsyncgetShortestPathRaw(context, request, cq));
    }
    virtual ::grpc::Status display(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpcICovisibilityGraphManager::displayResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>> Asyncdisplay(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>>(AsyncdisplayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>> PrepareAsyncdisplay(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>>(PrepareAsyncdisplayRaw(context, request, cq));
    }
    virtual ::grpc::Status saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpcICovisibilityGraphManager::saveToFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>> AsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>>(AsyncsaveToFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>> PrepareAsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>>(PrepareAsyncsaveToFileRaw(context, request, cq));
    }
    virtual ::grpc::Status loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>> AsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>>(AsyncloadFromFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>> PrepareAsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>>(PrepareAsyncloadFromFileRaw(context, request, cq));
    }
    virtual ::grpc::Status getConstCovisibilityGraph(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>> AsyncgetConstCovisibilityGraph(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>>(AsyncgetConstCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>> PrepareAsyncgetConstCovisibilityGraph(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>>(PrepareAsyncgetConstCovisibilityGraphRaw(context, request, cq));
    }
    virtual ::grpc::Status getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>> AsyncgetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>>(AsyncgetCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>> PrepareAsyncgetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>>(PrepareAsyncgetCovisibilityGraphRaw(context, request, cq));
    }
    virtual ::grpc::Status setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncsetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncsetCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncsetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncsetCovisibilityGraphRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void display(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::displayResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void display(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::displayResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getConstCovisibilityGraph(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getConstCovisibilityGraph(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>* AsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::increaseEdgeResponse>* PrepareAsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* AsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* PrepareAsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>* AsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::removeEdgeResponse>* PrepareAsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>* AsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getEdgeResponse>* PrepareAsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>* AsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::isEdgeResponse>* PrepareAsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>* AsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getAllNodesResponse>* PrepareAsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>* AsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::suppressNodeResponse>* PrepareAsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>* AsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getNeighborsResponse>* PrepareAsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* AsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* PrepareAsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* AsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* PrepareAsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>* AsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getShortestPathResponse>* PrepareAsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>* AsyncdisplayRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::displayResponse>* PrepareAsyncdisplayRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>* AsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::saveToFileResponse>* PrepareAsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>* AsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::loadFromFileResponse>* PrepareAsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* AsyncgetConstCovisibilityGraphRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* PrepareAsyncgetConstCovisibilityGraphRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* AsyncgetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* PrepareAsyncgetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncsetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncsetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>> AsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>>(AsyncincreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>> PrepareAsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>>(PrepareAsyncincreaseEdgeRaw(context, request, cq));
    }
    ::grpc::Status decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>> AsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>>(AsyncdecreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>> PrepareAsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>>(PrepareAsyncdecreaseEdgeRaw(context, request, cq));
    }
    ::grpc::Status removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>> AsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>>(AsyncremoveEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>> PrepareAsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>>(PrepareAsyncremoveEdgeRaw(context, request, cq));
    }
    ::grpc::Status getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpcICovisibilityGraphManager::getEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>> AsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>>(AsyncgetEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>> PrepareAsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>>(PrepareAsyncgetEdgeRaw(context, request, cq));
    }
    ::grpc::Status isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpcICovisibilityGraphManager::isEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>> AsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>>(AsyncisEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>> PrepareAsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>>(PrepareAsyncisEdgeRaw(context, request, cq));
    }
    ::grpc::Status getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>> AsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>>(AsyncgetAllNodesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>> PrepareAsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>>(PrepareAsyncgetAllNodesRaw(context, request, cq));
    }
    ::grpc::Status suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>> AsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>>(AsyncsuppressNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>> PrepareAsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>>(PrepareAsyncsuppressNodeRaw(context, request, cq));
    }
    ::grpc::Status getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>> AsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>>(AsyncgetNeighborsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>> PrepareAsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>>(PrepareAsyncgetNeighborsRaw(context, request, cq));
    }
    ::grpc::Status minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>> AsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>>(AsyncminimalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>> PrepareAsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>>(PrepareAsyncminimalSpanningTreeRaw(context, request, cq));
    }
    ::grpc::Status maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>> AsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>>(AsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>> PrepareAsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>>(PrepareAsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    ::grpc::Status getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>> AsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>>(AsyncgetShortestPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>> PrepareAsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>>(PrepareAsyncgetShortestPathRaw(context, request, cq));
    }
    ::grpc::Status display(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpcICovisibilityGraphManager::displayResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>> Asyncdisplay(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>>(AsyncdisplayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>> PrepareAsyncdisplay(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>>(PrepareAsyncdisplayRaw(context, request, cq));
    }
    ::grpc::Status saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpcICovisibilityGraphManager::saveToFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>> AsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>>(AsyncsaveToFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>> PrepareAsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>>(PrepareAsyncsaveToFileRaw(context, request, cq));
    }
    ::grpc::Status loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>> AsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>>(AsyncloadFromFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>> PrepareAsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>>(PrepareAsyncloadFromFileRaw(context, request, cq));
    }
    ::grpc::Status getConstCovisibilityGraph(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>> AsyncgetConstCovisibilityGraph(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>>(AsyncgetConstCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>> PrepareAsyncgetConstCovisibilityGraph(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>>(PrepareAsyncgetConstCovisibilityGraphRaw(context, request, cq));
    }
    ::grpc::Status getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>> AsyncgetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>>(AsyncgetCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>> PrepareAsyncgetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>>(PrepareAsyncgetCovisibilityGraphRaw(context, request, cq));
    }
    ::grpc::Status setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncsetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncsetCovisibilityGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncsetCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncsetCovisibilityGraphRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response, std::function<void(::grpc::Status)>) override;
      void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response, std::function<void(::grpc::Status)>) override;
      void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response, std::function<void(::grpc::Status)>) override;
      void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) override;
      void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) override;
      void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response, std::function<void(::grpc::Status)>) override;
      void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void display(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::displayResponse* response, std::function<void(::grpc::Status)>) override;
      void display(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::displayResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response, std::function<void(::grpc::Status)>) override;
      void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response, std::function<void(::grpc::Status)>) override;
      void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getConstCovisibilityGraph(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response, std::function<void(::grpc::Status)>) override;
      void getConstCovisibilityGraph(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response, std::function<void(::grpc::Status)>) override;
      void getCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void setCovisibilityGraph(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>* AsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::increaseEdgeResponse>* PrepareAsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* AsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* PrepareAsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>* AsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::removeEdgeResponse>* PrepareAsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>* AsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getEdgeResponse>* PrepareAsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>* AsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::isEdgeResponse>* PrepareAsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>* AsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getAllNodesResponse>* PrepareAsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>* AsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::suppressNodeResponse>* PrepareAsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>* AsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getNeighborsResponse>* PrepareAsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* AsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* PrepareAsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* AsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* PrepareAsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>* AsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getShortestPathResponse>* PrepareAsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>* AsyncdisplayRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::displayResponse>* PrepareAsyncdisplayRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>* AsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::saveToFileResponse>* PrepareAsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>* AsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::loadFromFileResponse>* PrepareAsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* AsyncgetConstCovisibilityGraphRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* PrepareAsyncgetConstCovisibilityGraphRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* AsyncgetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* PrepareAsyncgetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncsetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncsetCovisibilityGraphRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_increaseEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_decreaseEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_removeEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_getEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_isEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_getAllNodes_;
    const ::grpc::internal::RpcMethod rpcmethod_suppressNode_;
    const ::grpc::internal::RpcMethod rpcmethod_getNeighbors_;
    const ::grpc::internal::RpcMethod rpcmethod_minimalSpanningTree_;
    const ::grpc::internal::RpcMethod rpcmethod_maximalSpanningTree_;
    const ::grpc::internal::RpcMethod rpcmethod_getShortestPath_;
    const ::grpc::internal::RpcMethod rpcmethod_display_;
    const ::grpc::internal::RpcMethod rpcmethod_saveToFile_;
    const ::grpc::internal::RpcMethod rpcmethod_loadFromFile_;
    const ::grpc::internal::RpcMethod rpcmethod_getConstCovisibilityGraph_;
    const ::grpc::internal::RpcMethod rpcmethod_getCovisibilityGraph_;
    const ::grpc::internal::RpcMethod rpcmethod_setCovisibilityGraph_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status increaseEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response);
    virtual ::grpc::Status decreaseEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response);
    virtual ::grpc::Status removeEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response);
    virtual ::grpc::Status getEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response);
    virtual ::grpc::Status isEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response);
    virtual ::grpc::Status getAllNodes(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response);
    virtual ::grpc::Status suppressNode(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response);
    virtual ::grpc::Status getNeighbors(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response);
    virtual ::grpc::Status minimalSpanningTree(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response);
    virtual ::grpc::Status maximalSpanningTree(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response);
    virtual ::grpc::Status getShortestPath(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response);
    virtual ::grpc::Status display(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::displayResponse* response);
    virtual ::grpc::Status saveToFile(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response);
    virtual ::grpc::Status loadFromFile(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response);
    virtual ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response);
    virtual ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response);
    virtual ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_increaseEdge() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestincreaseEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::increaseEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdecreaseEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_removeEdge() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestremoveEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::removeEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getEdge() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isEdge() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::isEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getAllNodes() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAllNodes(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getAllNodesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_suppressNode() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsuppressNode(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::suppressNodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getNeighbors() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNeighbors(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getNeighborsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestminimalSpanningTree(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmaximalSpanningTree(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getShortestPath() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetShortestPath(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getShortestPathResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_display() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdisplay(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::displayResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveToFile() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveToFile(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::saveToFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_loadFromFile() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestloadFromFile(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::loadFromFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getConstCovisibilityGraph() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetConstCovisibilityGraph(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getCovisibilityGraph() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetCovisibilityGraph(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setCovisibilityGraph() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetCovisibilityGraph(::grpc::ServerContext* context, ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_increaseEdge<WithAsyncMethod_decreaseEdge<WithAsyncMethod_removeEdge<WithAsyncMethod_getEdge<WithAsyncMethod_isEdge<WithAsyncMethod_getAllNodes<WithAsyncMethod_suppressNode<WithAsyncMethod_getNeighbors<WithAsyncMethod_minimalSpanningTree<WithAsyncMethod_maximalSpanningTree<WithAsyncMethod_getShortestPath<WithAsyncMethod_display<WithAsyncMethod_saveToFile<WithAsyncMethod_loadFromFile<WithAsyncMethod_getConstCovisibilityGraph<WithAsyncMethod_getCovisibilityGraph<WithAsyncMethod_setCovisibilityGraph<Service > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_increaseEdge() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::increaseEdgeRequest, ::grpcICovisibilityGraphManager::increaseEdgeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* request, ::grpcICovisibilityGraphManager::increaseEdgeResponse* response) { return this->increaseEdge(context, request, response); }));}
    void SetMessageAllocatorFor_increaseEdge(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::increaseEdgeRequest, ::grpcICovisibilityGraphManager::increaseEdgeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::increaseEdgeRequest, ::grpcICovisibilityGraphManager::increaseEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* increaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::decreaseEdgeRequest, ::grpcICovisibilityGraphManager::decreaseEdgeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* request, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* response) { return this->decreaseEdge(context, request, response); }));}
    void SetMessageAllocatorFor_decreaseEdge(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::decreaseEdgeRequest, ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::decreaseEdgeRequest, ::grpcICovisibilityGraphManager::decreaseEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* decreaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_removeEdge() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::removeEdgeRequest, ::grpcICovisibilityGraphManager::removeEdgeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::removeEdgeRequest* request, ::grpcICovisibilityGraphManager::removeEdgeResponse* response) { return this->removeEdge(context, request, response); }));}
    void SetMessageAllocatorFor_removeEdge(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::removeEdgeRequest, ::grpcICovisibilityGraphManager::removeEdgeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::removeEdgeRequest, ::grpcICovisibilityGraphManager::removeEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* removeEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getEdge() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getEdgeRequest, ::grpcICovisibilityGraphManager::getEdgeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::getEdgeRequest* request, ::grpcICovisibilityGraphManager::getEdgeResponse* response) { return this->getEdge(context, request, response); }));}
    void SetMessageAllocatorFor_getEdge(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::getEdgeRequest, ::grpcICovisibilityGraphManager::getEdgeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getEdgeRequest, ::grpcICovisibilityGraphManager::getEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_isEdge() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::isEdgeRequest, ::grpcICovisibilityGraphManager::isEdgeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::isEdgeRequest* request, ::grpcICovisibilityGraphManager::isEdgeResponse* response) { return this->isEdge(context, request, response); }));}
    void SetMessageAllocatorFor_isEdge(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::isEdgeRequest, ::grpcICovisibilityGraphManager::isEdgeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::isEdgeRequest, ::grpcICovisibilityGraphManager::isEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getAllNodes() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getAllNodesRequest, ::grpcICovisibilityGraphManager::getAllNodesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::getAllNodesRequest* request, ::grpcICovisibilityGraphManager::getAllNodesResponse* response) { return this->getAllNodes(context, request, response); }));}
    void SetMessageAllocatorFor_getAllNodes(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::getAllNodesRequest, ::grpcICovisibilityGraphManager::getAllNodesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getAllNodesRequest, ::grpcICovisibilityGraphManager::getAllNodesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getAllNodes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_suppressNode() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::suppressNodeRequest, ::grpcICovisibilityGraphManager::suppressNodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::suppressNodeRequest* request, ::grpcICovisibilityGraphManager::suppressNodeResponse* response) { return this->suppressNode(context, request, response); }));}
    void SetMessageAllocatorFor_suppressNode(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::suppressNodeRequest, ::grpcICovisibilityGraphManager::suppressNodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::suppressNodeRequest, ::grpcICovisibilityGraphManager::suppressNodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* suppressNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getNeighbors() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getNeighborsRequest, ::grpcICovisibilityGraphManager::getNeighborsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::getNeighborsRequest* request, ::grpcICovisibilityGraphManager::getNeighborsResponse* response) { return this->getNeighbors(context, request, response); }));}
    void SetMessageAllocatorFor_getNeighbors(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::getNeighborsRequest, ::grpcICovisibilityGraphManager::getNeighborsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getNeighborsRequest, ::grpcICovisibilityGraphManager::getNeighborsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getNeighbors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* response) { return this->minimalSpanningTree(context, request, response); }));}
    void SetMessageAllocatorFor_minimalSpanningTree(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* minimalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* response) { return this->maximalSpanningTree(context, request, response); }));}
    void SetMessageAllocatorFor_maximalSpanningTree(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* maximalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getShortestPath() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getShortestPathRequest, ::grpcICovisibilityGraphManager::getShortestPathResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::getShortestPathRequest* request, ::grpcICovisibilityGraphManager::getShortestPathResponse* response) { return this->getShortestPath(context, request, response); }));}
    void SetMessageAllocatorFor_getShortestPath(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::getShortestPathRequest, ::grpcICovisibilityGraphManager::getShortestPathResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getShortestPathRequest, ::grpcICovisibilityGraphManager::getShortestPathResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getShortestPath(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_display() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::grpcICovisibilityGraphManager::displayResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::displayResponse* response) { return this->display(context, request, response); }));}
    void SetMessageAllocatorFor_display(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::grpcICovisibilityGraphManager::displayResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::grpcICovisibilityGraphManager::displayResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* display(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_saveToFile() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::saveToFileRequest, ::grpcICovisibilityGraphManager::saveToFileResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::saveToFileRequest* request, ::grpcICovisibilityGraphManager::saveToFileResponse* response) { return this->saveToFile(context, request, response); }));}
    void SetMessageAllocatorFor_saveToFile(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::saveToFileRequest, ::grpcICovisibilityGraphManager::saveToFileResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::saveToFileRequest, ::grpcICovisibilityGraphManager::saveToFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveToFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_loadFromFile() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::loadFromFileRequest, ::grpcICovisibilityGraphManager::loadFromFileResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::loadFromFileRequest* request, ::grpcICovisibilityGraphManager::loadFromFileResponse* response) { return this->loadFromFile(context, request, response); }));}
    void SetMessageAllocatorFor_loadFromFile(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::loadFromFileRequest, ::grpcICovisibilityGraphManager::loadFromFileResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::loadFromFileRequest, ::grpcICovisibilityGraphManager::loadFromFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* loadFromFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getConstCovisibilityGraph() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* response) { return this->getConstCovisibilityGraph(context, request, response); }));}
    void SetMessageAllocatorFor_getConstCovisibilityGraph(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getConstCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getCovisibilityGraph() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* request, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* response) { return this->getCovisibilityGraph(context, request, response); }));}
    void SetMessageAllocatorFor_getCovisibilityGraph(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setCovisibilityGraph() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* request, ::google::protobuf::Empty* response) { return this->setCovisibilityGraph(context, request, response); }));}
    void SetMessageAllocatorFor_setCovisibilityGraph(
        ::grpc::MessageAllocator< ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_increaseEdge<WithCallbackMethod_decreaseEdge<WithCallbackMethod_removeEdge<WithCallbackMethod_getEdge<WithCallbackMethod_isEdge<WithCallbackMethod_getAllNodes<WithCallbackMethod_suppressNode<WithCallbackMethod_getNeighbors<WithCallbackMethod_minimalSpanningTree<WithCallbackMethod_maximalSpanningTree<WithCallbackMethod_getShortestPath<WithCallbackMethod_display<WithCallbackMethod_saveToFile<WithCallbackMethod_loadFromFile<WithCallbackMethod_getConstCovisibilityGraph<WithCallbackMethod_getCovisibilityGraph<WithCallbackMethod_setCovisibilityGraph<Service > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_increaseEdge() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_removeEdge() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getEdge() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isEdge() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getAllNodes() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_suppressNode() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getNeighbors() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getShortestPath() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_display() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveToFile() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_loadFromFile() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getConstCovisibilityGraph() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getCovisibilityGraph() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setCovisibilityGraph() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_increaseEdge() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestincreaseEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdecreaseEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_removeEdge() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestremoveEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getEdge() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isEdge() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getAllNodes() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAllNodes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_suppressNode() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsuppressNode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getNeighbors() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNeighbors(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestminimalSpanningTree(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmaximalSpanningTree(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getShortestPath() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetShortestPath(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_display() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdisplay(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveToFile() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveToFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_loadFromFile() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestloadFromFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getConstCovisibilityGraph() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetConstCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getCovisibilityGraph() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setCovisibilityGraph() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_increaseEdge() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->increaseEdge(context, request, response); }));
    }
    ~WithRawCallbackMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* increaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->decreaseEdge(context, request, response); }));
    }
    ~WithRawCallbackMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* decreaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_removeEdge() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->removeEdge(context, request, response); }));
    }
    ~WithRawCallbackMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* removeEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getEdge() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getEdge(context, request, response); }));
    }
    ~WithRawCallbackMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_isEdge() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isEdge(context, request, response); }));
    }
    ~WithRawCallbackMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* isEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getAllNodes() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getAllNodes(context, request, response); }));
    }
    ~WithRawCallbackMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getAllNodes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_suppressNode() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->suppressNode(context, request, response); }));
    }
    ~WithRawCallbackMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* suppressNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getNeighbors() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getNeighbors(context, request, response); }));
    }
    ~WithRawCallbackMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getNeighbors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->minimalSpanningTree(context, request, response); }));
    }
    ~WithRawCallbackMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* minimalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->maximalSpanningTree(context, request, response); }));
    }
    ~WithRawCallbackMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* maximalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getShortestPath() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getShortestPath(context, request, response); }));
    }
    ~WithRawCallbackMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getShortestPath(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_display() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->display(context, request, response); }));
    }
    ~WithRawCallbackMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* display(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_saveToFile() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveToFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* saveToFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_loadFromFile() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->loadFromFile(context, request, response); }));
    }
    ~WithRawCallbackMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* loadFromFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getConstCovisibilityGraph() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getConstCovisibilityGraph(context, request, response); }));
    }
    ~WithRawCallbackMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getConstCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getCovisibilityGraph() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getCovisibilityGraph(context, request, response); }));
    }
    ~WithRawCallbackMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setCovisibilityGraph() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setCovisibilityGraph(context, request, response); }));
    }
    ~WithRawCallbackMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setCovisibilityGraph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_increaseEdge() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::increaseEdgeRequest, ::grpcICovisibilityGraphManager::increaseEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::increaseEdgeRequest, ::grpcICovisibilityGraphManager::increaseEdgeResponse>* streamer) {
                       return this->StreamedincreaseEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedincreaseEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::increaseEdgeRequest,::grpcICovisibilityGraphManager::increaseEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::decreaseEdgeRequest, ::grpcICovisibilityGraphManager::decreaseEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::decreaseEdgeRequest, ::grpcICovisibilityGraphManager::decreaseEdgeResponse>* streamer) {
                       return this->StreameddecreaseEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddecreaseEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::decreaseEdgeRequest,::grpcICovisibilityGraphManager::decreaseEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_removeEdge() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::removeEdgeRequest, ::grpcICovisibilityGraphManager::removeEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::removeEdgeRequest, ::grpcICovisibilityGraphManager::removeEdgeResponse>* streamer) {
                       return this->StreamedremoveEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedremoveEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::removeEdgeRequest,::grpcICovisibilityGraphManager::removeEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getEdge() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::getEdgeRequest, ::grpcICovisibilityGraphManager::getEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::getEdgeRequest, ::grpcICovisibilityGraphManager::getEdgeResponse>* streamer) {
                       return this->StreamedgetEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::getEdgeRequest,::grpcICovisibilityGraphManager::getEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isEdge() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::isEdgeRequest, ::grpcICovisibilityGraphManager::isEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::isEdgeRequest, ::grpcICovisibilityGraphManager::isEdgeResponse>* streamer) {
                       return this->StreamedisEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::isEdgeRequest* /*request*/, ::grpcICovisibilityGraphManager::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::isEdgeRequest,::grpcICovisibilityGraphManager::isEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getAllNodes() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::getAllNodesRequest, ::grpcICovisibilityGraphManager::getAllNodesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::getAllNodesRequest, ::grpcICovisibilityGraphManager::getAllNodesResponse>* streamer) {
                       return this->StreamedgetAllNodes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraphManager::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetAllNodes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::getAllNodesRequest,::grpcICovisibilityGraphManager::getAllNodesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_suppressNode() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::suppressNodeRequest, ::grpcICovisibilityGraphManager::suppressNodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::suppressNodeRequest, ::grpcICovisibilityGraphManager::suppressNodeResponse>* streamer) {
                       return this->StreamedsuppressNode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraphManager::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsuppressNode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::suppressNodeRequest,::grpcICovisibilityGraphManager::suppressNodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getNeighbors() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::getNeighborsRequest, ::grpcICovisibilityGraphManager::getNeighborsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::getNeighborsRequest, ::grpcICovisibilityGraphManager::getNeighborsResponse>* streamer) {
                       return this->StreamedgetNeighbors(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraphManager::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetNeighbors(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::getNeighborsRequest,::grpcICovisibilityGraphManager::getNeighborsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* streamer) {
                       return this->StreamedminimalSpanningTree(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedminimalSpanningTree(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::minimalSpanningTreeRequest,::grpcICovisibilityGraphManager::minimalSpanningTreeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* streamer) {
                       return this->StreamedmaximalSpanningTree(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraphManager::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmaximalSpanningTree(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::maximalSpanningTreeRequest,::grpcICovisibilityGraphManager::maximalSpanningTreeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getShortestPath() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::getShortestPathRequest, ::grpcICovisibilityGraphManager::getShortestPathResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::getShortestPathRequest, ::grpcICovisibilityGraphManager::getShortestPathResponse>* streamer) {
                       return this->StreamedgetShortestPath(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraphManager::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetShortestPath(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::getShortestPathRequest,::grpcICovisibilityGraphManager::getShortestPathResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_display() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::grpcICovisibilityGraphManager::displayResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::grpcICovisibilityGraphManager::displayResponse>* streamer) {
                       return this->Streameddisplay(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddisplay(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::grpcICovisibilityGraphManager::displayResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveToFile() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::saveToFileRequest, ::grpcICovisibilityGraphManager::saveToFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::saveToFileRequest, ::grpcICovisibilityGraphManager::saveToFileResponse>* streamer) {
                       return this->StreamedsaveToFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::saveToFileRequest* /*request*/, ::grpcICovisibilityGraphManager::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveToFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::saveToFileRequest,::grpcICovisibilityGraphManager::saveToFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_loadFromFile() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::loadFromFileRequest, ::grpcICovisibilityGraphManager::loadFromFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::loadFromFileRequest, ::grpcICovisibilityGraphManager::loadFromFileResponse>* streamer) {
                       return this->StreamedloadFromFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraphManager::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedloadFromFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::loadFromFileRequest,::grpcICovisibilityGraphManager::loadFromFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getConstCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getConstCovisibilityGraph() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* streamer) {
                       return this->StreamedgetConstCovisibilityGraph(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getConstCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getConstCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetConstCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::grpcICovisibilityGraphManager::getConstCovisibilityGraphResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getCovisibilityGraph() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* streamer) {
                       return this->StreamedgetCovisibilityGraph(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest* /*request*/, ::grpcICovisibilityGraphManager::getCovisibilityGraphResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::getCovisibilityGraphRequest,::grpcICovisibilityGraphManager::getCovisibilityGraphResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setCovisibilityGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setCovisibilityGraph() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedsetCovisibilityGraph(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setCovisibilityGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setCovisibilityGraph(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetCovisibilityGraph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraphManager::setCovisibilityGraphRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_increaseEdge<WithStreamedUnaryMethod_decreaseEdge<WithStreamedUnaryMethod_removeEdge<WithStreamedUnaryMethod_getEdge<WithStreamedUnaryMethod_isEdge<WithStreamedUnaryMethod_getAllNodes<WithStreamedUnaryMethod_suppressNode<WithStreamedUnaryMethod_getNeighbors<WithStreamedUnaryMethod_minimalSpanningTree<WithStreamedUnaryMethod_maximalSpanningTree<WithStreamedUnaryMethod_getShortestPath<WithStreamedUnaryMethod_display<WithStreamedUnaryMethod_saveToFile<WithStreamedUnaryMethod_loadFromFile<WithStreamedUnaryMethod_getConstCovisibilityGraph<WithStreamedUnaryMethod_getCovisibilityGraph<WithStreamedUnaryMethod_setCovisibilityGraph<Service > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_increaseEdge<WithStreamedUnaryMethod_decreaseEdge<WithStreamedUnaryMethod_removeEdge<WithStreamedUnaryMethod_getEdge<WithStreamedUnaryMethod_isEdge<WithStreamedUnaryMethod_getAllNodes<WithStreamedUnaryMethod_suppressNode<WithStreamedUnaryMethod_getNeighbors<WithStreamedUnaryMethod_minimalSpanningTree<WithStreamedUnaryMethod_maximalSpanningTree<WithStreamedUnaryMethod_getShortestPath<WithStreamedUnaryMethod_display<WithStreamedUnaryMethod_saveToFile<WithStreamedUnaryMethod_loadFromFile<WithStreamedUnaryMethod_getConstCovisibilityGraph<WithStreamedUnaryMethod_getCovisibilityGraph<WithStreamedUnaryMethod_setCovisibilityGraph<Service > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace grpcICovisibilityGraphManager


#endif  // GRPC_grpcICovisibilityGraphManagerService_2eproto__INCLUDED
