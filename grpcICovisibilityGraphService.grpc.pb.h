// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: grpcICovisibilityGraphService.proto
#ifndef GRPC_grpcICovisibilityGraphService_2eproto__INCLUDED
#define GRPC_grpcICovisibilityGraphService_2eproto__INCLUDED

#include "grpcICovisibilityGraphService.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpcICovisibilityGraph {

class grpcICovisibilityGraphService final {
 public:
  static constexpr char const* service_full_name() {
    return "grpcICovisibilityGraph.grpcICovisibilityGraphService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest& request, ::grpcICovisibilityGraph::increaseEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::increaseEdgeResponse>> AsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::increaseEdgeResponse>>(AsyncincreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::increaseEdgeResponse>> PrepareAsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::increaseEdgeResponse>>(PrepareAsyncincreaseEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest& request, ::grpcICovisibilityGraph::decreaseEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::decreaseEdgeResponse>> AsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::decreaseEdgeResponse>>(AsyncdecreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::decreaseEdgeResponse>> PrepareAsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::decreaseEdgeResponse>>(PrepareAsyncdecreaseEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest& request, ::grpcICovisibilityGraph::removeEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::removeEdgeResponse>> AsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::removeEdgeResponse>>(AsyncremoveEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::removeEdgeResponse>> PrepareAsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::removeEdgeResponse>>(PrepareAsyncremoveEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest& request, ::grpcICovisibilityGraph::getEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getEdgeResponse>> AsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getEdgeResponse>>(AsyncgetEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getEdgeResponse>> PrepareAsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getEdgeResponse>>(PrepareAsyncgetEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest& request, ::grpcICovisibilityGraph::isEdgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::isEdgeResponse>> AsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::isEdgeResponse>>(AsyncisEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::isEdgeResponse>> PrepareAsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::isEdgeResponse>>(PrepareAsyncisEdgeRaw(context, request, cq));
    }
    virtual ::grpc::Status getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest& request, ::grpcICovisibilityGraph::getAllNodesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getAllNodesResponse>> AsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getAllNodesResponse>>(AsyncgetAllNodesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getAllNodesResponse>> PrepareAsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getAllNodesResponse>>(PrepareAsyncgetAllNodesRaw(context, request, cq));
    }
    virtual ::grpc::Status suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest& request, ::grpcICovisibilityGraph::suppressNodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::suppressNodeResponse>> AsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::suppressNodeResponse>>(AsyncsuppressNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::suppressNodeResponse>> PrepareAsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::suppressNodeResponse>>(PrepareAsyncsuppressNodeRaw(context, request, cq));
    }
    virtual ::grpc::Status getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest& request, ::grpcICovisibilityGraph::getNeighborsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getNeighborsResponse>> AsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getNeighborsResponse>>(AsyncgetNeighborsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getNeighborsResponse>> PrepareAsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getNeighborsResponse>>(PrepareAsyncgetNeighborsRaw(context, request, cq));
    }
    virtual ::grpc::Status minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest& request, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>> AsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>>(AsyncminimalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>> PrepareAsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>>(PrepareAsyncminimalSpanningTreeRaw(context, request, cq));
    }
    virtual ::grpc::Status maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest& request, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>> AsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>>(AsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>> PrepareAsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>>(PrepareAsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    virtual ::grpc::Status getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest& request, ::grpcICovisibilityGraph::getShortestPathResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getShortestPathResponse>> AsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getShortestPathResponse>>(AsyncgetShortestPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getShortestPathResponse>> PrepareAsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getShortestPathResponse>>(PrepareAsyncgetShortestPathRaw(context, request, cq));
    }
    virtual ::grpc::Status display(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpcICovisibilityGraph::displayResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::displayResponse>> Asyncdisplay(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::displayResponse>>(AsyncdisplayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::displayResponse>> PrepareAsyncdisplay(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::displayResponse>>(PrepareAsyncdisplayRaw(context, request, cq));
    }
    virtual ::grpc::Status saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest& request, ::grpcICovisibilityGraph::saveToFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::saveToFileResponse>> AsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::saveToFileResponse>>(AsyncsaveToFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::saveToFileResponse>> PrepareAsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::saveToFileResponse>>(PrepareAsyncsaveToFileRaw(context, request, cq));
    }
    virtual ::grpc::Status loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest& request, ::grpcICovisibilityGraph::loadFromFileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::loadFromFileResponse>> AsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::loadFromFileResponse>>(AsyncloadFromFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::loadFromFileResponse>> PrepareAsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::loadFromFileResponse>>(PrepareAsyncloadFromFileRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest* request, ::grpcICovisibilityGraph::increaseEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest* request, ::grpcICovisibilityGraph::increaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest* request, ::grpcICovisibilityGraph::increaseEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest* request, ::grpcICovisibilityGraph::decreaseEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest* request, ::grpcICovisibilityGraph::decreaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest* request, ::grpcICovisibilityGraph::decreaseEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest* request, ::grpcICovisibilityGraph::removeEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest* request, ::grpcICovisibilityGraph::removeEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest* request, ::grpcICovisibilityGraph::removeEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest* request, ::grpcICovisibilityGraph::getEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest* request, ::grpcICovisibilityGraph::getEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest* request, ::grpcICovisibilityGraph::getEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest* request, ::grpcICovisibilityGraph::isEdgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest* request, ::grpcICovisibilityGraph::isEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest* request, ::grpcICovisibilityGraph::isEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest* request, ::grpcICovisibilityGraph::getAllNodesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest* request, ::grpcICovisibilityGraph::getAllNodesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest* request, ::grpcICovisibilityGraph::getAllNodesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest* request, ::grpcICovisibilityGraph::suppressNodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest* request, ::grpcICovisibilityGraph::suppressNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest* request, ::grpcICovisibilityGraph::suppressNodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest* request, ::grpcICovisibilityGraph::getNeighborsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest* request, ::grpcICovisibilityGraph::getNeighborsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest* request, ::grpcICovisibilityGraph::getNeighborsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest* request, ::grpcICovisibilityGraph::getShortestPathResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest* request, ::grpcICovisibilityGraph::getShortestPathResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest* request, ::grpcICovisibilityGraph::getShortestPathResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void display(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraph::displayResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void display(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraph::displayResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void display(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraph::displayResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest* request, ::grpcICovisibilityGraph::saveToFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest* request, ::grpcICovisibilityGraph::saveToFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest* request, ::grpcICovisibilityGraph::saveToFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest* request, ::grpcICovisibilityGraph::loadFromFileResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest* request, ::grpcICovisibilityGraph::loadFromFileResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest* request, ::grpcICovisibilityGraph::loadFromFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::increaseEdgeResponse>* AsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::increaseEdgeResponse>* PrepareAsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::decreaseEdgeResponse>* AsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::decreaseEdgeResponse>* PrepareAsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::removeEdgeResponse>* AsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::removeEdgeResponse>* PrepareAsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getEdgeResponse>* AsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getEdgeResponse>* PrepareAsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::isEdgeResponse>* AsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::isEdgeResponse>* PrepareAsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getAllNodesResponse>* AsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getAllNodesResponse>* PrepareAsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::suppressNodeResponse>* AsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::suppressNodeResponse>* PrepareAsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getNeighborsResponse>* AsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getNeighborsResponse>* PrepareAsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>* AsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>* PrepareAsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>* AsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>* PrepareAsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getShortestPathResponse>* AsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::getShortestPathResponse>* PrepareAsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::displayResponse>* AsyncdisplayRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::displayResponse>* PrepareAsyncdisplayRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::saveToFileResponse>* AsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::saveToFileResponse>* PrepareAsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::loadFromFileResponse>* AsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::grpcICovisibilityGraph::loadFromFileResponse>* PrepareAsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest& request, ::grpcICovisibilityGraph::increaseEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::increaseEdgeResponse>> AsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::increaseEdgeResponse>>(AsyncincreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::increaseEdgeResponse>> PrepareAsyncincreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::increaseEdgeResponse>>(PrepareAsyncincreaseEdgeRaw(context, request, cq));
    }
    ::grpc::Status decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest& request, ::grpcICovisibilityGraph::decreaseEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::decreaseEdgeResponse>> AsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::decreaseEdgeResponse>>(AsyncdecreaseEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::decreaseEdgeResponse>> PrepareAsyncdecreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::decreaseEdgeResponse>>(PrepareAsyncdecreaseEdgeRaw(context, request, cq));
    }
    ::grpc::Status removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest& request, ::grpcICovisibilityGraph::removeEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::removeEdgeResponse>> AsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::removeEdgeResponse>>(AsyncremoveEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::removeEdgeResponse>> PrepareAsyncremoveEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::removeEdgeResponse>>(PrepareAsyncremoveEdgeRaw(context, request, cq));
    }
    ::grpc::Status getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest& request, ::grpcICovisibilityGraph::getEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getEdgeResponse>> AsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getEdgeResponse>>(AsyncgetEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getEdgeResponse>> PrepareAsyncgetEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getEdgeResponse>>(PrepareAsyncgetEdgeRaw(context, request, cq));
    }
    ::grpc::Status isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest& request, ::grpcICovisibilityGraph::isEdgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::isEdgeResponse>> AsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::isEdgeResponse>>(AsyncisEdgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::isEdgeResponse>> PrepareAsyncisEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::isEdgeResponse>>(PrepareAsyncisEdgeRaw(context, request, cq));
    }
    ::grpc::Status getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest& request, ::grpcICovisibilityGraph::getAllNodesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getAllNodesResponse>> AsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getAllNodesResponse>>(AsyncgetAllNodesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getAllNodesResponse>> PrepareAsyncgetAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getAllNodesResponse>>(PrepareAsyncgetAllNodesRaw(context, request, cq));
    }
    ::grpc::Status suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest& request, ::grpcICovisibilityGraph::suppressNodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::suppressNodeResponse>> AsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::suppressNodeResponse>>(AsyncsuppressNodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::suppressNodeResponse>> PrepareAsyncsuppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::suppressNodeResponse>>(PrepareAsyncsuppressNodeRaw(context, request, cq));
    }
    ::grpc::Status getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest& request, ::grpcICovisibilityGraph::getNeighborsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getNeighborsResponse>> AsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getNeighborsResponse>>(AsyncgetNeighborsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getNeighborsResponse>> PrepareAsyncgetNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getNeighborsResponse>>(PrepareAsyncgetNeighborsRaw(context, request, cq));
    }
    ::grpc::Status minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest& request, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>> AsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>>(AsyncminimalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>> PrepareAsyncminimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>>(PrepareAsyncminimalSpanningTreeRaw(context, request, cq));
    }
    ::grpc::Status maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest& request, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>> AsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>>(AsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>> PrepareAsyncmaximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>>(PrepareAsyncmaximalSpanningTreeRaw(context, request, cq));
    }
    ::grpc::Status getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest& request, ::grpcICovisibilityGraph::getShortestPathResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getShortestPathResponse>> AsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getShortestPathResponse>>(AsyncgetShortestPathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getShortestPathResponse>> PrepareAsyncgetShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getShortestPathResponse>>(PrepareAsyncgetShortestPathRaw(context, request, cq));
    }
    ::grpc::Status display(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpcICovisibilityGraph::displayResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::displayResponse>> Asyncdisplay(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::displayResponse>>(AsyncdisplayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::displayResponse>> PrepareAsyncdisplay(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::displayResponse>>(PrepareAsyncdisplayRaw(context, request, cq));
    }
    ::grpc::Status saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest& request, ::grpcICovisibilityGraph::saveToFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::saveToFileResponse>> AsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::saveToFileResponse>>(AsyncsaveToFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::saveToFileResponse>> PrepareAsyncsaveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::saveToFileResponse>>(PrepareAsyncsaveToFileRaw(context, request, cq));
    }
    ::grpc::Status loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest& request, ::grpcICovisibilityGraph::loadFromFileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::loadFromFileResponse>> AsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::loadFromFileResponse>>(AsyncloadFromFileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::loadFromFileResponse>> PrepareAsyncloadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::loadFromFileResponse>>(PrepareAsyncloadFromFileRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest* request, ::grpcICovisibilityGraph::increaseEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest* request, ::grpcICovisibilityGraph::increaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void increaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest* request, ::grpcICovisibilityGraph::increaseEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest* request, ::grpcICovisibilityGraph::decreaseEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest* request, ::grpcICovisibilityGraph::decreaseEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void decreaseEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest* request, ::grpcICovisibilityGraph::decreaseEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest* request, ::grpcICovisibilityGraph::removeEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest* request, ::grpcICovisibilityGraph::removeEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void removeEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest* request, ::grpcICovisibilityGraph::removeEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest* request, ::grpcICovisibilityGraph::getEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest* request, ::grpcICovisibilityGraph::getEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest* request, ::grpcICovisibilityGraph::getEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest* request, ::grpcICovisibilityGraph::isEdgeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest* request, ::grpcICovisibilityGraph::isEdgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void isEdge(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest* request, ::grpcICovisibilityGraph::isEdgeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest* request, ::grpcICovisibilityGraph::getAllNodesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest* request, ::grpcICovisibilityGraph::getAllNodesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getAllNodes(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest* request, ::grpcICovisibilityGraph::getAllNodesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest* request, ::grpcICovisibilityGraph::suppressNodeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest* request, ::grpcICovisibilityGraph::suppressNodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void suppressNode(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest* request, ::grpcICovisibilityGraph::suppressNodeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest* request, ::grpcICovisibilityGraph::getNeighborsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest* request, ::grpcICovisibilityGraph::getNeighborsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getNeighbors(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest* request, ::grpcICovisibilityGraph::getNeighborsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void minimalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void maximalSpanningTree(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest* request, ::grpcICovisibilityGraph::getShortestPathResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest* request, ::grpcICovisibilityGraph::getShortestPathResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void getShortestPath(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest* request, ::grpcICovisibilityGraph::getShortestPathResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void display(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraph::displayResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void display(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraph::displayResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void display(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraph::displayResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest* request, ::grpcICovisibilityGraph::saveToFileResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest* request, ::grpcICovisibilityGraph::saveToFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void saveToFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest* request, ::grpcICovisibilityGraph::saveToFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest* request, ::grpcICovisibilityGraph::loadFromFileResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest* request, ::grpcICovisibilityGraph::loadFromFileResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void loadFromFile(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest* request, ::grpcICovisibilityGraph::loadFromFileResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::increaseEdgeResponse>* AsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::increaseEdgeResponse>* PrepareAsyncincreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::decreaseEdgeResponse>* AsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::decreaseEdgeResponse>* PrepareAsyncdecreaseEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::removeEdgeResponse>* AsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::removeEdgeResponse>* PrepareAsyncremoveEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getEdgeResponse>* AsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getEdgeResponse>* PrepareAsyncgetEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::isEdgeResponse>* AsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::isEdgeResponse>* PrepareAsyncisEdgeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::isEdgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getAllNodesResponse>* AsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getAllNodesResponse>* PrepareAsyncgetAllNodesRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::suppressNodeResponse>* AsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::suppressNodeResponse>* PrepareAsyncsuppressNodeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getNeighborsResponse>* AsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getNeighborsResponse>* PrepareAsyncgetNeighborsRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>* AsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>* PrepareAsyncminimalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>* AsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>* PrepareAsyncmaximalSpanningTreeRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getShortestPathResponse>* AsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::getShortestPathResponse>* PrepareAsyncgetShortestPathRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::displayResponse>* AsyncdisplayRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::displayResponse>* PrepareAsyncdisplayRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::saveToFileResponse>* AsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::saveToFileResponse>* PrepareAsyncsaveToFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::saveToFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::loadFromFileResponse>* AsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::grpcICovisibilityGraph::loadFromFileResponse>* PrepareAsyncloadFromFileRaw(::grpc::ClientContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_increaseEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_decreaseEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_removeEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_getEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_isEdge_;
    const ::grpc::internal::RpcMethod rpcmethod_getAllNodes_;
    const ::grpc::internal::RpcMethod rpcmethod_suppressNode_;
    const ::grpc::internal::RpcMethod rpcmethod_getNeighbors_;
    const ::grpc::internal::RpcMethod rpcmethod_minimalSpanningTree_;
    const ::grpc::internal::RpcMethod rpcmethod_maximalSpanningTree_;
    const ::grpc::internal::RpcMethod rpcmethod_getShortestPath_;
    const ::grpc::internal::RpcMethod rpcmethod_display_;
    const ::grpc::internal::RpcMethod rpcmethod_saveToFile_;
    const ::grpc::internal::RpcMethod rpcmethod_loadFromFile_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status increaseEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::increaseEdgeRequest* request, ::grpcICovisibilityGraph::increaseEdgeResponse* response);
    virtual ::grpc::Status decreaseEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::decreaseEdgeRequest* request, ::grpcICovisibilityGraph::decreaseEdgeResponse* response);
    virtual ::grpc::Status removeEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::removeEdgeRequest* request, ::grpcICovisibilityGraph::removeEdgeResponse* response);
    virtual ::grpc::Status getEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::getEdgeRequest* request, ::grpcICovisibilityGraph::getEdgeResponse* response);
    virtual ::grpc::Status isEdge(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::isEdgeRequest* request, ::grpcICovisibilityGraph::isEdgeResponse* response);
    virtual ::grpc::Status getAllNodes(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::getAllNodesRequest* request, ::grpcICovisibilityGraph::getAllNodesResponse* response);
    virtual ::grpc::Status suppressNode(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::suppressNodeRequest* request, ::grpcICovisibilityGraph::suppressNodeResponse* response);
    virtual ::grpc::Status getNeighbors(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::getNeighborsRequest* request, ::grpcICovisibilityGraph::getNeighborsResponse* response);
    virtual ::grpc::Status minimalSpanningTree(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* response);
    virtual ::grpc::Status maximalSpanningTree(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* response);
    virtual ::grpc::Status getShortestPath(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::getShortestPathRequest* request, ::grpcICovisibilityGraph::getShortestPathResponse* response);
    virtual ::grpc::Status display(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraph::displayResponse* response);
    virtual ::grpc::Status saveToFile(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::saveToFileRequest* request, ::grpcICovisibilityGraph::saveToFileResponse* response);
    virtual ::grpc::Status loadFromFile(::grpc::ServerContext* context, const ::grpcICovisibilityGraph::loadFromFileRequest* request, ::grpcICovisibilityGraph::loadFromFileResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_increaseEdge() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestincreaseEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraph::increaseEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::increaseEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdecreaseEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraph::decreaseEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::decreaseEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_removeEdge() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraph::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestremoveEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraph::removeEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::removeEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getEdge() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getEdgeRequest* /*request*/, ::grpcICovisibilityGraph::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraph::getEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::getEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_isEdge() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::isEdgeRequest* /*request*/, ::grpcICovisibilityGraph::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisEdge(::grpc::ServerContext* context, ::grpcICovisibilityGraph::isEdgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::isEdgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getAllNodes() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraph::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAllNodes(::grpc::ServerContext* context, ::grpcICovisibilityGraph::getAllNodesRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::getAllNodesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_suppressNode() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraph::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsuppressNode(::grpc::ServerContext* context, ::grpcICovisibilityGraph::suppressNodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::suppressNodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getNeighbors() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraph::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNeighbors(::grpc::ServerContext* context, ::grpcICovisibilityGraph::getNeighborsRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::getNeighborsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestminimalSpanningTree(::grpc::ServerContext* context, ::grpcICovisibilityGraph::minimalSpanningTreeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::minimalSpanningTreeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmaximalSpanningTree(::grpc::ServerContext* context, ::grpcICovisibilityGraph::maximalSpanningTreeRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::maximalSpanningTreeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getShortestPath() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraph::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetShortestPath(::grpc::ServerContext* context, ::grpcICovisibilityGraph::getShortestPathRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::getShortestPathResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_display() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraph::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdisplay(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::displayResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_saveToFile() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::saveToFileRequest* /*request*/, ::grpcICovisibilityGraph::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveToFile(::grpc::ServerContext* context, ::grpcICovisibilityGraph::saveToFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::saveToFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_loadFromFile() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraph::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestloadFromFile(::grpc::ServerContext* context, ::grpcICovisibilityGraph::loadFromFileRequest* request, ::grpc::ServerAsyncResponseWriter< ::grpcICovisibilityGraph::loadFromFileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_increaseEdge<WithAsyncMethod_decreaseEdge<WithAsyncMethod_removeEdge<WithAsyncMethod_getEdge<WithAsyncMethod_isEdge<WithAsyncMethod_getAllNodes<WithAsyncMethod_suppressNode<WithAsyncMethod_getNeighbors<WithAsyncMethod_minimalSpanningTree<WithAsyncMethod_maximalSpanningTree<WithAsyncMethod_getShortestPath<WithAsyncMethod_display<WithAsyncMethod_saveToFile<WithAsyncMethod_loadFromFile<Service > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_increaseEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::increaseEdgeRequest, ::grpcICovisibilityGraph::increaseEdgeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::increaseEdgeRequest* request, ::grpcICovisibilityGraph::increaseEdgeResponse* response) { return this->increaseEdge(context, request, response); }));}
    void SetMessageAllocatorFor_increaseEdge(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::increaseEdgeRequest, ::grpcICovisibilityGraph::increaseEdgeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::increaseEdgeRequest, ::grpcICovisibilityGraph::increaseEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* increaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::increaseEdgeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* increaseEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::increaseEdgeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_decreaseEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::decreaseEdgeRequest, ::grpcICovisibilityGraph::decreaseEdgeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::decreaseEdgeRequest* request, ::grpcICovisibilityGraph::decreaseEdgeResponse* response) { return this->decreaseEdge(context, request, response); }));}
    void SetMessageAllocatorFor_decreaseEdge(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::decreaseEdgeRequest, ::grpcICovisibilityGraph::decreaseEdgeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::decreaseEdgeRequest, ::grpcICovisibilityGraph::decreaseEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* decreaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::decreaseEdgeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* decreaseEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::decreaseEdgeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_removeEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::removeEdgeRequest, ::grpcICovisibilityGraph::removeEdgeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::removeEdgeRequest* request, ::grpcICovisibilityGraph::removeEdgeResponse* response) { return this->removeEdge(context, request, response); }));}
    void SetMessageAllocatorFor_removeEdge(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::removeEdgeRequest, ::grpcICovisibilityGraph::removeEdgeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::removeEdgeRequest, ::grpcICovisibilityGraph::removeEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraph::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* removeEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraph::removeEdgeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* removeEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraph::removeEdgeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::getEdgeRequest, ::grpcICovisibilityGraph::getEdgeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::getEdgeRequest* request, ::grpcICovisibilityGraph::getEdgeResponse* response) { return this->getEdge(context, request, response); }));}
    void SetMessageAllocatorFor_getEdge(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::getEdgeRequest, ::grpcICovisibilityGraph::getEdgeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::getEdgeRequest, ::grpcICovisibilityGraph::getEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getEdgeRequest* /*request*/, ::grpcICovisibilityGraph::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::getEdgeRequest* /*request*/, ::grpcICovisibilityGraph::getEdgeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::getEdgeRequest* /*request*/, ::grpcICovisibilityGraph::getEdgeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_isEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::isEdgeRequest, ::grpcICovisibilityGraph::isEdgeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::isEdgeRequest* request, ::grpcICovisibilityGraph::isEdgeResponse* response) { return this->isEdge(context, request, response); }));}
    void SetMessageAllocatorFor_isEdge(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::isEdgeRequest, ::grpcICovisibilityGraph::isEdgeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::isEdgeRequest, ::grpcICovisibilityGraph::isEdgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::isEdgeRequest* /*request*/, ::grpcICovisibilityGraph::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* isEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::isEdgeRequest* /*request*/, ::grpcICovisibilityGraph::isEdgeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* isEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::isEdgeRequest* /*request*/, ::grpcICovisibilityGraph::isEdgeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getAllNodes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::getAllNodesRequest, ::grpcICovisibilityGraph::getAllNodesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::getAllNodesRequest* request, ::grpcICovisibilityGraph::getAllNodesResponse* response) { return this->getAllNodes(context, request, response); }));}
    void SetMessageAllocatorFor_getAllNodes(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::getAllNodesRequest, ::grpcICovisibilityGraph::getAllNodesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::getAllNodesRequest, ::grpcICovisibilityGraph::getAllNodesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraph::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getAllNodes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraph::getAllNodesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getAllNodes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraph::getAllNodesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_suppressNode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::suppressNodeRequest, ::grpcICovisibilityGraph::suppressNodeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::suppressNodeRequest* request, ::grpcICovisibilityGraph::suppressNodeResponse* response) { return this->suppressNode(context, request, response); }));}
    void SetMessageAllocatorFor_suppressNode(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::suppressNodeRequest, ::grpcICovisibilityGraph::suppressNodeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::suppressNodeRequest, ::grpcICovisibilityGraph::suppressNodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraph::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* suppressNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraph::suppressNodeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* suppressNode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraph::suppressNodeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getNeighbors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::getNeighborsRequest, ::grpcICovisibilityGraph::getNeighborsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::getNeighborsRequest* request, ::grpcICovisibilityGraph::getNeighborsResponse* response) { return this->getNeighbors(context, request, response); }));}
    void SetMessageAllocatorFor_getNeighbors(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::getNeighborsRequest, ::grpcICovisibilityGraph::getNeighborsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::getNeighborsRequest, ::grpcICovisibilityGraph::getNeighborsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraph::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getNeighbors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraph::getNeighborsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getNeighbors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraph::getNeighborsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_minimalSpanningTree() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::minimalSpanningTreeRequest, ::grpcICovisibilityGraph::minimalSpanningTreeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* request, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* response) { return this->minimalSpanningTree(context, request, response); }));}
    void SetMessageAllocatorFor_minimalSpanningTree(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::minimalSpanningTreeRequest, ::grpcICovisibilityGraph::minimalSpanningTreeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::minimalSpanningTreeRequest, ::grpcICovisibilityGraph::minimalSpanningTreeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* minimalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* minimalSpanningTree(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_maximalSpanningTree() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::maximalSpanningTreeRequest, ::grpcICovisibilityGraph::maximalSpanningTreeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* request, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* response) { return this->maximalSpanningTree(context, request, response); }));}
    void SetMessageAllocatorFor_maximalSpanningTree(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::maximalSpanningTreeRequest, ::grpcICovisibilityGraph::maximalSpanningTreeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::maximalSpanningTreeRequest, ::grpcICovisibilityGraph::maximalSpanningTreeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* maximalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* maximalSpanningTree(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_getShortestPath() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::getShortestPathRequest, ::grpcICovisibilityGraph::getShortestPathResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::getShortestPathRequest* request, ::grpcICovisibilityGraph::getShortestPathResponse* response) { return this->getShortestPath(context, request, response); }));}
    void SetMessageAllocatorFor_getShortestPath(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::getShortestPathRequest, ::grpcICovisibilityGraph::getShortestPathResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::getShortestPathRequest, ::grpcICovisibilityGraph::getShortestPathResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraph::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getShortestPath(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraph::getShortestPathResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getShortestPath(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraph::getShortestPathResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_display() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::grpcICovisibilityGraph::displayResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::grpcICovisibilityGraph::displayResponse* response) { return this->display(context, request, response); }));}
    void SetMessageAllocatorFor_display(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::grpcICovisibilityGraph::displayResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::grpcICovisibilityGraph::displayResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraph::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* display(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraph::displayResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* display(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraph::displayResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_saveToFile() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::saveToFileRequest, ::grpcICovisibilityGraph::saveToFileResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::saveToFileRequest* request, ::grpcICovisibilityGraph::saveToFileResponse* response) { return this->saveToFile(context, request, response); }));}
    void SetMessageAllocatorFor_saveToFile(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::saveToFileRequest, ::grpcICovisibilityGraph::saveToFileResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::saveToFileRequest, ::grpcICovisibilityGraph::saveToFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::saveToFileRequest* /*request*/, ::grpcICovisibilityGraph::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* saveToFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::saveToFileRequest* /*request*/, ::grpcICovisibilityGraph::saveToFileResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* saveToFile(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::saveToFileRequest* /*request*/, ::grpcICovisibilityGraph::saveToFileResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_loadFromFile() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::loadFromFileRequest, ::grpcICovisibilityGraph::loadFromFileResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpcICovisibilityGraph::loadFromFileRequest* request, ::grpcICovisibilityGraph::loadFromFileResponse* response) { return this->loadFromFile(context, request, response); }));}
    void SetMessageAllocatorFor_loadFromFile(
        ::grpc::experimental::MessageAllocator< ::grpcICovisibilityGraph::loadFromFileRequest, ::grpcICovisibilityGraph::loadFromFileResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::grpcICovisibilityGraph::loadFromFileRequest, ::grpcICovisibilityGraph::loadFromFileResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraph::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* loadFromFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraph::loadFromFileResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* loadFromFile(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpcICovisibilityGraph::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraph::loadFromFileResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_increaseEdge<ExperimentalWithCallbackMethod_decreaseEdge<ExperimentalWithCallbackMethod_removeEdge<ExperimentalWithCallbackMethod_getEdge<ExperimentalWithCallbackMethod_isEdge<ExperimentalWithCallbackMethod_getAllNodes<ExperimentalWithCallbackMethod_suppressNode<ExperimentalWithCallbackMethod_getNeighbors<ExperimentalWithCallbackMethod_minimalSpanningTree<ExperimentalWithCallbackMethod_maximalSpanningTree<ExperimentalWithCallbackMethod_getShortestPath<ExperimentalWithCallbackMethod_display<ExperimentalWithCallbackMethod_saveToFile<ExperimentalWithCallbackMethod_loadFromFile<Service > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_increaseEdge<ExperimentalWithCallbackMethod_decreaseEdge<ExperimentalWithCallbackMethod_removeEdge<ExperimentalWithCallbackMethod_getEdge<ExperimentalWithCallbackMethod_isEdge<ExperimentalWithCallbackMethod_getAllNodes<ExperimentalWithCallbackMethod_suppressNode<ExperimentalWithCallbackMethod_getNeighbors<ExperimentalWithCallbackMethod_minimalSpanningTree<ExperimentalWithCallbackMethod_maximalSpanningTree<ExperimentalWithCallbackMethod_getShortestPath<ExperimentalWithCallbackMethod_display<ExperimentalWithCallbackMethod_saveToFile<ExperimentalWithCallbackMethod_loadFromFile<Service > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_increaseEdge() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_removeEdge() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraph::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getEdge() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getEdgeRequest* /*request*/, ::grpcICovisibilityGraph::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_isEdge() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::isEdgeRequest* /*request*/, ::grpcICovisibilityGraph::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getAllNodes() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraph::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_suppressNode() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraph::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getNeighbors() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraph::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getShortestPath() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraph::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_display() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraph::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_saveToFile() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::saveToFileRequest* /*request*/, ::grpcICovisibilityGraph::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_loadFromFile() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraph::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_increaseEdge() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestincreaseEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestdecreaseEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_removeEdge() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraph::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestremoveEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getEdge() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getEdgeRequest* /*request*/, ::grpcICovisibilityGraph::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_isEdge() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::isEdgeRequest* /*request*/, ::grpcICovisibilityGraph::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestisEdge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getAllNodes() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraph::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAllNodes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_suppressNode() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraph::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsuppressNode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getNeighbors() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraph::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNeighbors(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestminimalSpanningTree(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmaximalSpanningTree(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getShortestPath() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraph::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetShortestPath(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_display() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraph::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdisplay(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_saveToFile() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::saveToFileRequest* /*request*/, ::grpcICovisibilityGraph::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsaveToFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_loadFromFile() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraph::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestloadFromFile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_increaseEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->increaseEdge(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* increaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* increaseEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_decreaseEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->decreaseEdge(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* decreaseEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* decreaseEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_removeEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->removeEdge(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraph::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* removeEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* removeEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getEdge(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getEdgeRequest* /*request*/, ::grpcICovisibilityGraph::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_isEdge() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->isEdge(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::isEdgeRequest* /*request*/, ::grpcICovisibilityGraph::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* isEdge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* isEdge(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getAllNodes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getAllNodes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraph::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getAllNodes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getAllNodes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_suppressNode() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->suppressNode(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraph::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* suppressNode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* suppressNode(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getNeighbors() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getNeighbors(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraph::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getNeighbors(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getNeighbors(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_minimalSpanningTree() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->minimalSpanningTree(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* minimalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* minimalSpanningTree(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_maximalSpanningTree() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->maximalSpanningTree(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* maximalSpanningTree(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* maximalSpanningTree(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_getShortestPath() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getShortestPath(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraph::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* getShortestPath(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* getShortestPath(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_display() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->display(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraph::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* display(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* display(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_saveToFile() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->saveToFile(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::saveToFileRequest* /*request*/, ::grpcICovisibilityGraph::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* saveToFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* saveToFile(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_loadFromFile() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->loadFromFile(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraph::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* loadFromFile(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* loadFromFile(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_increaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_increaseEdge() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::increaseEdgeRequest, ::grpcICovisibilityGraph::increaseEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::increaseEdgeRequest, ::grpcICovisibilityGraph::increaseEdgeResponse>* streamer) {
                       return this->StreamedincreaseEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_increaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status increaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::increaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::increaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedincreaseEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::increaseEdgeRequest,::grpcICovisibilityGraph::increaseEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_decreaseEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_decreaseEdge() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::decreaseEdgeRequest, ::grpcICovisibilityGraph::decreaseEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::decreaseEdgeRequest, ::grpcICovisibilityGraph::decreaseEdgeResponse>* streamer) {
                       return this->StreameddecreaseEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_decreaseEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status decreaseEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::decreaseEdgeRequest* /*request*/, ::grpcICovisibilityGraph::decreaseEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreameddecreaseEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::decreaseEdgeRequest,::grpcICovisibilityGraph::decreaseEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_removeEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_removeEdge() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::removeEdgeRequest, ::grpcICovisibilityGraph::removeEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::removeEdgeRequest, ::grpcICovisibilityGraph::removeEdgeResponse>* streamer) {
                       return this->StreamedremoveEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_removeEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status removeEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::removeEdgeRequest* /*request*/, ::grpcICovisibilityGraph::removeEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedremoveEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::removeEdgeRequest,::grpcICovisibilityGraph::removeEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getEdge() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::getEdgeRequest, ::grpcICovisibilityGraph::getEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::getEdgeRequest, ::grpcICovisibilityGraph::getEdgeResponse>* streamer) {
                       return this->StreamedgetEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getEdgeRequest* /*request*/, ::grpcICovisibilityGraph::getEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::getEdgeRequest,::grpcICovisibilityGraph::getEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_isEdge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_isEdge() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::isEdgeRequest, ::grpcICovisibilityGraph::isEdgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::isEdgeRequest, ::grpcICovisibilityGraph::isEdgeResponse>* streamer) {
                       return this->StreamedisEdge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_isEdge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status isEdge(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::isEdgeRequest* /*request*/, ::grpcICovisibilityGraph::isEdgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedisEdge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::isEdgeRequest,::grpcICovisibilityGraph::isEdgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getAllNodes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getAllNodes() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::getAllNodesRequest, ::grpcICovisibilityGraph::getAllNodesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::getAllNodesRequest, ::grpcICovisibilityGraph::getAllNodesResponse>* streamer) {
                       return this->StreamedgetAllNodes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getAllNodes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getAllNodes(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getAllNodesRequest* /*request*/, ::grpcICovisibilityGraph::getAllNodesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetAllNodes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::getAllNodesRequest,::grpcICovisibilityGraph::getAllNodesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_suppressNode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_suppressNode() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::suppressNodeRequest, ::grpcICovisibilityGraph::suppressNodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::suppressNodeRequest, ::grpcICovisibilityGraph::suppressNodeResponse>* streamer) {
                       return this->StreamedsuppressNode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_suppressNode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status suppressNode(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::suppressNodeRequest* /*request*/, ::grpcICovisibilityGraph::suppressNodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsuppressNode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::suppressNodeRequest,::grpcICovisibilityGraph::suppressNodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getNeighbors : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getNeighbors() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::getNeighborsRequest, ::grpcICovisibilityGraph::getNeighborsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::getNeighborsRequest, ::grpcICovisibilityGraph::getNeighborsResponse>* streamer) {
                       return this->StreamedgetNeighbors(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getNeighbors() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getNeighbors(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getNeighborsRequest* /*request*/, ::grpcICovisibilityGraph::getNeighborsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetNeighbors(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::getNeighborsRequest,::grpcICovisibilityGraph::getNeighborsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_minimalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_minimalSpanningTree() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::minimalSpanningTreeRequest, ::grpcICovisibilityGraph::minimalSpanningTreeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::minimalSpanningTreeRequest, ::grpcICovisibilityGraph::minimalSpanningTreeResponse>* streamer) {
                       return this->StreamedminimalSpanningTree(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_minimalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status minimalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::minimalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::minimalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedminimalSpanningTree(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::minimalSpanningTreeRequest,::grpcICovisibilityGraph::minimalSpanningTreeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_maximalSpanningTree : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_maximalSpanningTree() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::maximalSpanningTreeRequest, ::grpcICovisibilityGraph::maximalSpanningTreeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::maximalSpanningTreeRequest, ::grpcICovisibilityGraph::maximalSpanningTreeResponse>* streamer) {
                       return this->StreamedmaximalSpanningTree(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_maximalSpanningTree() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status maximalSpanningTree(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::maximalSpanningTreeRequest* /*request*/, ::grpcICovisibilityGraph::maximalSpanningTreeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmaximalSpanningTree(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::maximalSpanningTreeRequest,::grpcICovisibilityGraph::maximalSpanningTreeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getShortestPath : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getShortestPath() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::getShortestPathRequest, ::grpcICovisibilityGraph::getShortestPathResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::getShortestPathRequest, ::grpcICovisibilityGraph::getShortestPathResponse>* streamer) {
                       return this->StreamedgetShortestPath(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getShortestPath() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getShortestPath(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::getShortestPathRequest* /*request*/, ::grpcICovisibilityGraph::getShortestPathResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetShortestPath(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::getShortestPathRequest,::grpcICovisibilityGraph::getShortestPathResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_display : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_display() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::grpcICovisibilityGraph::displayResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::grpcICovisibilityGraph::displayResponse>* streamer) {
                       return this->Streameddisplay(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_display() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status display(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::grpcICovisibilityGraph::displayResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddisplay(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::grpcICovisibilityGraph::displayResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_saveToFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_saveToFile() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::saveToFileRequest, ::grpcICovisibilityGraph::saveToFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::saveToFileRequest, ::grpcICovisibilityGraph::saveToFileResponse>* streamer) {
                       return this->StreamedsaveToFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_saveToFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status saveToFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::saveToFileRequest* /*request*/, ::grpcICovisibilityGraph::saveToFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsaveToFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::saveToFileRequest,::grpcICovisibilityGraph::saveToFileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_loadFromFile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_loadFromFile() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::grpcICovisibilityGraph::loadFromFileRequest, ::grpcICovisibilityGraph::loadFromFileResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::grpcICovisibilityGraph::loadFromFileRequest, ::grpcICovisibilityGraph::loadFromFileResponse>* streamer) {
                       return this->StreamedloadFromFile(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_loadFromFile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status loadFromFile(::grpc::ServerContext* /*context*/, const ::grpcICovisibilityGraph::loadFromFileRequest* /*request*/, ::grpcICovisibilityGraph::loadFromFileResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedloadFromFile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::grpcICovisibilityGraph::loadFromFileRequest,::grpcICovisibilityGraph::loadFromFileResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_increaseEdge<WithStreamedUnaryMethod_decreaseEdge<WithStreamedUnaryMethod_removeEdge<WithStreamedUnaryMethod_getEdge<WithStreamedUnaryMethod_isEdge<WithStreamedUnaryMethod_getAllNodes<WithStreamedUnaryMethod_suppressNode<WithStreamedUnaryMethod_getNeighbors<WithStreamedUnaryMethod_minimalSpanningTree<WithStreamedUnaryMethod_maximalSpanningTree<WithStreamedUnaryMethod_getShortestPath<WithStreamedUnaryMethod_display<WithStreamedUnaryMethod_saveToFile<WithStreamedUnaryMethod_loadFromFile<Service > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_increaseEdge<WithStreamedUnaryMethod_decreaseEdge<WithStreamedUnaryMethod_removeEdge<WithStreamedUnaryMethod_getEdge<WithStreamedUnaryMethod_isEdge<WithStreamedUnaryMethod_getAllNodes<WithStreamedUnaryMethod_suppressNode<WithStreamedUnaryMethod_getNeighbors<WithStreamedUnaryMethod_minimalSpanningTree<WithStreamedUnaryMethod_maximalSpanningTree<WithStreamedUnaryMethod_getShortestPath<WithStreamedUnaryMethod_display<WithStreamedUnaryMethod_saveToFile<WithStreamedUnaryMethod_loadFromFile<Service > > > > > > > > > > > > > > StreamedService;
};

}  // namespace grpcICovisibilityGraph


#endif  // GRPC_grpcICovisibilityGraphService_2eproto__INCLUDED
