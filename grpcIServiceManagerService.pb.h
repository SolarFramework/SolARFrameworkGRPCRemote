// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpcIServiceManagerService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_grpcIServiceManagerService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_grpcIServiceManagerService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_grpcIServiceManagerService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_grpcIServiceManagerService_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_grpcIServiceManagerService_2eproto;
namespace grpcIServiceManager {
class getAndLockServiceRequest;
struct getAndLockServiceRequestDefaultTypeInternal;
extern getAndLockServiceRequestDefaultTypeInternal _getAndLockServiceRequest_default_instance_;
class getAndLockServiceResponse;
struct getAndLockServiceResponseDefaultTypeInternal;
extern getAndLockServiceResponseDefaultTypeInternal _getAndLockServiceResponse_default_instance_;
class getServiceRequest;
struct getServiceRequestDefaultTypeInternal;
extern getServiceRequestDefaultTypeInternal _getServiceRequest_default_instance_;
class getServiceResponse;
struct getServiceResponseDefaultTypeInternal;
extern getServiceResponseDefaultTypeInternal _getServiceResponse_default_instance_;
class initRequest;
struct initRequestDefaultTypeInternal;
extern initRequestDefaultTypeInternal _initRequest_default_instance_;
class initResponse;
struct initResponseDefaultTypeInternal;
extern initResponseDefaultTypeInternal _initResponse_default_instance_;
class registerServiceRequest;
struct registerServiceRequestDefaultTypeInternal;
extern registerServiceRequestDefaultTypeInternal _registerServiceRequest_default_instance_;
class registerServiceResponse;
struct registerServiceResponseDefaultTypeInternal;
extern registerServiceResponseDefaultTypeInternal _registerServiceResponse_default_instance_;
class unlockServiceRequest;
struct unlockServiceRequestDefaultTypeInternal;
extern unlockServiceRequestDefaultTypeInternal _unlockServiceRequest_default_instance_;
class unlockServiceResponse;
struct unlockServiceResponseDefaultTypeInternal;
extern unlockServiceResponseDefaultTypeInternal _unlockServiceResponse_default_instance_;
class unregisterServiceRequest;
struct unregisterServiceRequestDefaultTypeInternal;
extern unregisterServiceRequestDefaultTypeInternal _unregisterServiceRequest_default_instance_;
class unregisterServiceResponse;
struct unregisterServiceResponseDefaultTypeInternal;
extern unregisterServiceResponseDefaultTypeInternal _unregisterServiceResponse_default_instance_;
}  // namespace grpcIServiceManager
PROTOBUF_NAMESPACE_OPEN
template<> ::grpcIServiceManager::getAndLockServiceRequest* Arena::CreateMaybeMessage<::grpcIServiceManager::getAndLockServiceRequest>(Arena*);
template<> ::grpcIServiceManager::getAndLockServiceResponse* Arena::CreateMaybeMessage<::grpcIServiceManager::getAndLockServiceResponse>(Arena*);
template<> ::grpcIServiceManager::getServiceRequest* Arena::CreateMaybeMessage<::grpcIServiceManager::getServiceRequest>(Arena*);
template<> ::grpcIServiceManager::getServiceResponse* Arena::CreateMaybeMessage<::grpcIServiceManager::getServiceResponse>(Arena*);
template<> ::grpcIServiceManager::initRequest* Arena::CreateMaybeMessage<::grpcIServiceManager::initRequest>(Arena*);
template<> ::grpcIServiceManager::initResponse* Arena::CreateMaybeMessage<::grpcIServiceManager::initResponse>(Arena*);
template<> ::grpcIServiceManager::registerServiceRequest* Arena::CreateMaybeMessage<::grpcIServiceManager::registerServiceRequest>(Arena*);
template<> ::grpcIServiceManager::registerServiceResponse* Arena::CreateMaybeMessage<::grpcIServiceManager::registerServiceResponse>(Arena*);
template<> ::grpcIServiceManager::unlockServiceRequest* Arena::CreateMaybeMessage<::grpcIServiceManager::unlockServiceRequest>(Arena*);
template<> ::grpcIServiceManager::unlockServiceResponse* Arena::CreateMaybeMessage<::grpcIServiceManager::unlockServiceResponse>(Arena*);
template<> ::grpcIServiceManager::unregisterServiceRequest* Arena::CreateMaybeMessage<::grpcIServiceManager::unregisterServiceRequest>(Arena*);
template<> ::grpcIServiceManager::unregisterServiceResponse* Arena::CreateMaybeMessage<::grpcIServiceManager::unregisterServiceResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace grpcIServiceManager {

// ===================================================================

class initRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.initRequest) */ {
 public:
  inline initRequest() : initRequest(nullptr) {}
  ~initRequest() override;
  explicit PROTOBUF_CONSTEXPR initRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  initRequest(const initRequest& from);
  initRequest(initRequest&& from) noexcept
    : initRequest() {
    *this = ::std::move(from);
  }

  inline initRequest& operator=(const initRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline initRequest& operator=(initRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const initRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const initRequest* internal_default_instance() {
    return reinterpret_cast<const initRequest*>(
               &_initRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(initRequest& a, initRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(initRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(initRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  initRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<initRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const initRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const initRequest& from) {
    initRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(initRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.initRequest";
  }
  protected:
  explicit initRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.initRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// -------------------------------------------------------------------

class initResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.initResponse) */ {
 public:
  inline initResponse() : initResponse(nullptr) {}
  ~initResponse() override;
  explicit PROTOBUF_CONSTEXPR initResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  initResponse(const initResponse& from);
  initResponse(initResponse&& from) noexcept
    : initResponse() {
    *this = ::std::move(from);
  }

  inline initResponse& operator=(const initResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline initResponse& operator=(initResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const initResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const initResponse* internal_default_instance() {
    return reinterpret_cast<const initResponse*>(
               &_initResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(initResponse& a, initResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(initResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(initResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  initResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<initResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const initResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const initResponse& from) {
    initResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(initResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.initResponse";
  }
  protected:
  explicit initResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.initResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// -------------------------------------------------------------------

class registerServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.registerServiceRequest) */ {
 public:
  inline registerServiceRequest() : registerServiceRequest(nullptr) {}
  ~registerServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR registerServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  registerServiceRequest(const registerServiceRequest& from);
  registerServiceRequest(registerServiceRequest&& from) noexcept
    : registerServiceRequest() {
    *this = ::std::move(from);
  }

  inline registerServiceRequest& operator=(const registerServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline registerServiceRequest& operator=(registerServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const registerServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const registerServiceRequest* internal_default_instance() {
    return reinterpret_cast<const registerServiceRequest*>(
               &_registerServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(registerServiceRequest& a, registerServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(registerServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(registerServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  registerServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<registerServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const registerServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const registerServiceRequest& from) {
    registerServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(registerServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.registerServiceRequest";
  }
  protected:
  explicit registerServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceURLFieldNumber = 3,
    kGrpcServerCompressionFormatFieldNumber = 1,
    kServiceTypeFieldNumber = 2,
  };
  // string serviceURL = 3;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // sint32 serviceType = 2;
  void clear_servicetype();
  int32_t servicetype() const;
  void set_servicetype(int32_t value);
  private:
  int32_t _internal_servicetype() const;
  void _internal_set_servicetype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.registerServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t grpcservercompressionformat_;
    int32_t servicetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// -------------------------------------------------------------------

class registerServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.registerServiceResponse) */ {
 public:
  inline registerServiceResponse() : registerServiceResponse(nullptr) {}
  ~registerServiceResponse() override;
  explicit PROTOBUF_CONSTEXPR registerServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  registerServiceResponse(const registerServiceResponse& from);
  registerServiceResponse(registerServiceResponse&& from) noexcept
    : registerServiceResponse() {
    *this = ::std::move(from);
  }

  inline registerServiceResponse& operator=(const registerServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline registerServiceResponse& operator=(registerServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const registerServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const registerServiceResponse* internal_default_instance() {
    return reinterpret_cast<const registerServiceResponse*>(
               &_registerServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(registerServiceResponse& a, registerServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(registerServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(registerServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  registerServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<registerServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const registerServiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const registerServiceResponse& from) {
    registerServiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(registerServiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.registerServiceResponse";
  }
  protected:
  explicit registerServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.registerServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// -------------------------------------------------------------------

class unregisterServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.unregisterServiceRequest) */ {
 public:
  inline unregisterServiceRequest() : unregisterServiceRequest(nullptr) {}
  ~unregisterServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR unregisterServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  unregisterServiceRequest(const unregisterServiceRequest& from);
  unregisterServiceRequest(unregisterServiceRequest&& from) noexcept
    : unregisterServiceRequest() {
    *this = ::std::move(from);
  }

  inline unregisterServiceRequest& operator=(const unregisterServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline unregisterServiceRequest& operator=(unregisterServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const unregisterServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const unregisterServiceRequest* internal_default_instance() {
    return reinterpret_cast<const unregisterServiceRequest*>(
               &_unregisterServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(unregisterServiceRequest& a, unregisterServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(unregisterServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(unregisterServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  unregisterServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<unregisterServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const unregisterServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const unregisterServiceRequest& from) {
    unregisterServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(unregisterServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.unregisterServiceRequest";
  }
  protected:
  explicit unregisterServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceURLFieldNumber = 3,
    kGrpcServerCompressionFormatFieldNumber = 1,
    kServiceTypeFieldNumber = 2,
  };
  // string serviceURL = 3;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // sint32 serviceType = 2;
  void clear_servicetype();
  int32_t servicetype() const;
  void set_servicetype(int32_t value);
  private:
  int32_t _internal_servicetype() const;
  void _internal_set_servicetype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.unregisterServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t grpcservercompressionformat_;
    int32_t servicetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// -------------------------------------------------------------------

class unregisterServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.unregisterServiceResponse) */ {
 public:
  inline unregisterServiceResponse() : unregisterServiceResponse(nullptr) {}
  ~unregisterServiceResponse() override;
  explicit PROTOBUF_CONSTEXPR unregisterServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  unregisterServiceResponse(const unregisterServiceResponse& from);
  unregisterServiceResponse(unregisterServiceResponse&& from) noexcept
    : unregisterServiceResponse() {
    *this = ::std::move(from);
  }

  inline unregisterServiceResponse& operator=(const unregisterServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline unregisterServiceResponse& operator=(unregisterServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const unregisterServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const unregisterServiceResponse* internal_default_instance() {
    return reinterpret_cast<const unregisterServiceResponse*>(
               &_unregisterServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(unregisterServiceResponse& a, unregisterServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(unregisterServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(unregisterServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  unregisterServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<unregisterServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const unregisterServiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const unregisterServiceResponse& from) {
    unregisterServiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(unregisterServiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.unregisterServiceResponse";
  }
  protected:
  explicit unregisterServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.unregisterServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// -------------------------------------------------------------------

class getServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.getServiceRequest) */ {
 public:
  inline getServiceRequest() : getServiceRequest(nullptr) {}
  ~getServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR getServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getServiceRequest(const getServiceRequest& from);
  getServiceRequest(getServiceRequest&& from) noexcept
    : getServiceRequest() {
    *this = ::std::move(from);
  }

  inline getServiceRequest& operator=(const getServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline getServiceRequest& operator=(getServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const getServiceRequest* internal_default_instance() {
    return reinterpret_cast<const getServiceRequest*>(
               &_getServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(getServiceRequest& a, getServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(getServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getServiceRequest& from) {
    getServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.getServiceRequest";
  }
  protected:
  explicit getServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceURLFieldNumber = 3,
    kGrpcServerCompressionFormatFieldNumber = 1,
    kServiceTypeFieldNumber = 2,
  };
  // string serviceURL = 3;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // sint32 serviceType = 2;
  void clear_servicetype();
  int32_t servicetype() const;
  void set_servicetype(int32_t value);
  private:
  int32_t _internal_servicetype() const;
  void _internal_set_servicetype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.getServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t grpcservercompressionformat_;
    int32_t servicetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// -------------------------------------------------------------------

class getServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.getServiceResponse) */ {
 public:
  inline getServiceResponse() : getServiceResponse(nullptr) {}
  ~getServiceResponse() override;
  explicit PROTOBUF_CONSTEXPR getServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getServiceResponse(const getServiceResponse& from);
  getServiceResponse(getServiceResponse&& from) noexcept
    : getServiceResponse() {
    *this = ::std::move(from);
  }

  inline getServiceResponse& operator=(const getServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline getServiceResponse& operator=(getServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const getServiceResponse* internal_default_instance() {
    return reinterpret_cast<const getServiceResponse*>(
               &_getServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(getServiceResponse& a, getServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(getServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getServiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getServiceResponse& from) {
    getServiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getServiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.getServiceResponse";
  }
  protected:
  explicit getServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceURLFieldNumber = 1,
    kXpcfGrpcReturnValueFieldNumber = 2,
  };
  // string serviceURL = 1;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // sint32 xpcfGrpcReturnValue = 2;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.getServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// -------------------------------------------------------------------

class getAndLockServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.getAndLockServiceRequest) */ {
 public:
  inline getAndLockServiceRequest() : getAndLockServiceRequest(nullptr) {}
  ~getAndLockServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR getAndLockServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getAndLockServiceRequest(const getAndLockServiceRequest& from);
  getAndLockServiceRequest(getAndLockServiceRequest&& from) noexcept
    : getAndLockServiceRequest() {
    *this = ::std::move(from);
  }

  inline getAndLockServiceRequest& operator=(const getAndLockServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline getAndLockServiceRequest& operator=(getAndLockServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getAndLockServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const getAndLockServiceRequest* internal_default_instance() {
    return reinterpret_cast<const getAndLockServiceRequest*>(
               &_getAndLockServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(getAndLockServiceRequest& a, getAndLockServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(getAndLockServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getAndLockServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getAndLockServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getAndLockServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getAndLockServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getAndLockServiceRequest& from) {
    getAndLockServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getAndLockServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.getAndLockServiceRequest";
  }
  protected:
  explicit getAndLockServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUUIDFieldNumber = 3,
    kServiceURLFieldNumber = 4,
    kGrpcServerCompressionFormatFieldNumber = 1,
    kServiceTypeFieldNumber = 2,
  };
  // string clientUUID = 3;
  void clear_clientuuid();
  const std::string& clientuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientuuid();
  PROTOBUF_NODISCARD std::string* release_clientuuid();
  void set_allocated_clientuuid(std::string* clientuuid);
  private:
  const std::string& _internal_clientuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuuid(const std::string& value);
  std::string* _internal_mutable_clientuuid();
  public:

  // string serviceURL = 4;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // sint32 serviceType = 2;
  void clear_servicetype();
  int32_t servicetype() const;
  void set_servicetype(int32_t value);
  private:
  int32_t _internal_servicetype() const;
  void _internal_set_servicetype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.getAndLockServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientuuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t grpcservercompressionformat_;
    int32_t servicetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// -------------------------------------------------------------------

class getAndLockServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.getAndLockServiceResponse) */ {
 public:
  inline getAndLockServiceResponse() : getAndLockServiceResponse(nullptr) {}
  ~getAndLockServiceResponse() override;
  explicit PROTOBUF_CONSTEXPR getAndLockServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getAndLockServiceResponse(const getAndLockServiceResponse& from);
  getAndLockServiceResponse(getAndLockServiceResponse&& from) noexcept
    : getAndLockServiceResponse() {
    *this = ::std::move(from);
  }

  inline getAndLockServiceResponse& operator=(const getAndLockServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline getAndLockServiceResponse& operator=(getAndLockServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getAndLockServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const getAndLockServiceResponse* internal_default_instance() {
    return reinterpret_cast<const getAndLockServiceResponse*>(
               &_getAndLockServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(getAndLockServiceResponse& a, getAndLockServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(getAndLockServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getAndLockServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getAndLockServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getAndLockServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getAndLockServiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getAndLockServiceResponse& from) {
    getAndLockServiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getAndLockServiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.getAndLockServiceResponse";
  }
  protected:
  explicit getAndLockServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceURLFieldNumber = 1,
    kXpcfGrpcReturnValueFieldNumber = 2,
  };
  // string serviceURL = 1;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // sint32 xpcfGrpcReturnValue = 2;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.getAndLockServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// -------------------------------------------------------------------

class unlockServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.unlockServiceRequest) */ {
 public:
  inline unlockServiceRequest() : unlockServiceRequest(nullptr) {}
  ~unlockServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR unlockServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  unlockServiceRequest(const unlockServiceRequest& from);
  unlockServiceRequest(unlockServiceRequest&& from) noexcept
    : unlockServiceRequest() {
    *this = ::std::move(from);
  }

  inline unlockServiceRequest& operator=(const unlockServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline unlockServiceRequest& operator=(unlockServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const unlockServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const unlockServiceRequest* internal_default_instance() {
    return reinterpret_cast<const unlockServiceRequest*>(
               &_unlockServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(unlockServiceRequest& a, unlockServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(unlockServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(unlockServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  unlockServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<unlockServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const unlockServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const unlockServiceRequest& from) {
    unlockServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(unlockServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.unlockServiceRequest";
  }
  protected:
  explicit unlockServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUUIDFieldNumber = 3,
    kGrpcServerCompressionFormatFieldNumber = 1,
    kServiceTypeFieldNumber = 2,
  };
  // string clientUUID = 3;
  void clear_clientuuid();
  const std::string& clientuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientuuid();
  PROTOBUF_NODISCARD std::string* release_clientuuid();
  void set_allocated_clientuuid(std::string* clientuuid);
  private:
  const std::string& _internal_clientuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuuid(const std::string& value);
  std::string* _internal_mutable_clientuuid();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // sint32 serviceType = 2;
  void clear_servicetype();
  int32_t servicetype() const;
  void set_servicetype(int32_t value);
  private:
  int32_t _internal_servicetype() const;
  void _internal_set_servicetype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.unlockServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientuuid_;
    int32_t grpcservercompressionformat_;
    int32_t servicetype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// -------------------------------------------------------------------

class unlockServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIServiceManager.unlockServiceResponse) */ {
 public:
  inline unlockServiceResponse() : unlockServiceResponse(nullptr) {}
  ~unlockServiceResponse() override;
  explicit PROTOBUF_CONSTEXPR unlockServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  unlockServiceResponse(const unlockServiceResponse& from);
  unlockServiceResponse(unlockServiceResponse&& from) noexcept
    : unlockServiceResponse() {
    *this = ::std::move(from);
  }

  inline unlockServiceResponse& operator=(const unlockServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline unlockServiceResponse& operator=(unlockServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const unlockServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const unlockServiceResponse* internal_default_instance() {
    return reinterpret_cast<const unlockServiceResponse*>(
               &_unlockServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(unlockServiceResponse& a, unlockServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(unlockServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(unlockServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  unlockServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<unlockServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const unlockServiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const unlockServiceResponse& from) {
    unlockServiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(unlockServiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIServiceManager.unlockServiceResponse";
  }
  protected:
  explicit unlockServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIServiceManager.unlockServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIServiceManagerService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// initRequest

// int32 grpcServerCompressionFormat = 1;
inline void initRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t initRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t initRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.initRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void initRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void initRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.initRequest.grpcServerCompressionFormat)
}

// -------------------------------------------------------------------

// initResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void initResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t initResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t initResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.initResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void initResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void initResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.initResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// registerServiceRequest

// int32 grpcServerCompressionFormat = 1;
inline void registerServiceRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t registerServiceRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t registerServiceRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.registerServiceRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void registerServiceRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void registerServiceRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.registerServiceRequest.grpcServerCompressionFormat)
}

// sint32 serviceType = 2;
inline void registerServiceRequest::clear_servicetype() {
  _impl_.servicetype_ = 0;
}
inline int32_t registerServiceRequest::_internal_servicetype() const {
  return _impl_.servicetype_;
}
inline int32_t registerServiceRequest::servicetype() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.registerServiceRequest.serviceType)
  return _internal_servicetype();
}
inline void registerServiceRequest::_internal_set_servicetype(int32_t value) {
  
  _impl_.servicetype_ = value;
}
inline void registerServiceRequest::set_servicetype(int32_t value) {
  _internal_set_servicetype(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.registerServiceRequest.serviceType)
}

// string serviceURL = 3;
inline void registerServiceRequest::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& registerServiceRequest::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.registerServiceRequest.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void registerServiceRequest::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIServiceManager.registerServiceRequest.serviceURL)
}
inline std::string* registerServiceRequest::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIServiceManager.registerServiceRequest.serviceURL)
  return _s;
}
inline const std::string& registerServiceRequest::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void registerServiceRequest::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* registerServiceRequest::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* registerServiceRequest::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIServiceManager.registerServiceRequest.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void registerServiceRequest::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIServiceManager.registerServiceRequest.serviceURL)
}

// -------------------------------------------------------------------

// registerServiceResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void registerServiceResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t registerServiceResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t registerServiceResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.registerServiceResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void registerServiceResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void registerServiceResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.registerServiceResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// unregisterServiceRequest

// int32 grpcServerCompressionFormat = 1;
inline void unregisterServiceRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t unregisterServiceRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t unregisterServiceRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.unregisterServiceRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void unregisterServiceRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void unregisterServiceRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.unregisterServiceRequest.grpcServerCompressionFormat)
}

// sint32 serviceType = 2;
inline void unregisterServiceRequest::clear_servicetype() {
  _impl_.servicetype_ = 0;
}
inline int32_t unregisterServiceRequest::_internal_servicetype() const {
  return _impl_.servicetype_;
}
inline int32_t unregisterServiceRequest::servicetype() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.unregisterServiceRequest.serviceType)
  return _internal_servicetype();
}
inline void unregisterServiceRequest::_internal_set_servicetype(int32_t value) {
  
  _impl_.servicetype_ = value;
}
inline void unregisterServiceRequest::set_servicetype(int32_t value) {
  _internal_set_servicetype(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.unregisterServiceRequest.serviceType)
}

// string serviceURL = 3;
inline void unregisterServiceRequest::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& unregisterServiceRequest::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.unregisterServiceRequest.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void unregisterServiceRequest::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIServiceManager.unregisterServiceRequest.serviceURL)
}
inline std::string* unregisterServiceRequest::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIServiceManager.unregisterServiceRequest.serviceURL)
  return _s;
}
inline const std::string& unregisterServiceRequest::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void unregisterServiceRequest::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* unregisterServiceRequest::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* unregisterServiceRequest::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIServiceManager.unregisterServiceRequest.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void unregisterServiceRequest::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIServiceManager.unregisterServiceRequest.serviceURL)
}

// -------------------------------------------------------------------

// unregisterServiceResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void unregisterServiceResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t unregisterServiceResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t unregisterServiceResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.unregisterServiceResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void unregisterServiceResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void unregisterServiceResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.unregisterServiceResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// getServiceRequest

// int32 grpcServerCompressionFormat = 1;
inline void getServiceRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t getServiceRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t getServiceRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.getServiceRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void getServiceRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void getServiceRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.getServiceRequest.grpcServerCompressionFormat)
}

// sint32 serviceType = 2;
inline void getServiceRequest::clear_servicetype() {
  _impl_.servicetype_ = 0;
}
inline int32_t getServiceRequest::_internal_servicetype() const {
  return _impl_.servicetype_;
}
inline int32_t getServiceRequest::servicetype() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.getServiceRequest.serviceType)
  return _internal_servicetype();
}
inline void getServiceRequest::_internal_set_servicetype(int32_t value) {
  
  _impl_.servicetype_ = value;
}
inline void getServiceRequest::set_servicetype(int32_t value) {
  _internal_set_servicetype(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.getServiceRequest.serviceType)
}

// string serviceURL = 3;
inline void getServiceRequest::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& getServiceRequest::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.getServiceRequest.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getServiceRequest::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIServiceManager.getServiceRequest.serviceURL)
}
inline std::string* getServiceRequest::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIServiceManager.getServiceRequest.serviceURL)
  return _s;
}
inline const std::string& getServiceRequest::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void getServiceRequest::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* getServiceRequest::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* getServiceRequest::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIServiceManager.getServiceRequest.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void getServiceRequest::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIServiceManager.getServiceRequest.serviceURL)
}

// -------------------------------------------------------------------

// getServiceResponse

// string serviceURL = 1;
inline void getServiceResponse::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& getServiceResponse::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.getServiceResponse.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getServiceResponse::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIServiceManager.getServiceResponse.serviceURL)
}
inline std::string* getServiceResponse::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIServiceManager.getServiceResponse.serviceURL)
  return _s;
}
inline const std::string& getServiceResponse::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void getServiceResponse::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* getServiceResponse::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* getServiceResponse::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIServiceManager.getServiceResponse.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void getServiceResponse::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIServiceManager.getServiceResponse.serviceURL)
}

// sint32 xpcfGrpcReturnValue = 2;
inline void getServiceResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t getServiceResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t getServiceResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.getServiceResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void getServiceResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void getServiceResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.getServiceResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// getAndLockServiceRequest

// int32 grpcServerCompressionFormat = 1;
inline void getAndLockServiceRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t getAndLockServiceRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t getAndLockServiceRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.getAndLockServiceRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void getAndLockServiceRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void getAndLockServiceRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.getAndLockServiceRequest.grpcServerCompressionFormat)
}

// sint32 serviceType = 2;
inline void getAndLockServiceRequest::clear_servicetype() {
  _impl_.servicetype_ = 0;
}
inline int32_t getAndLockServiceRequest::_internal_servicetype() const {
  return _impl_.servicetype_;
}
inline int32_t getAndLockServiceRequest::servicetype() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.getAndLockServiceRequest.serviceType)
  return _internal_servicetype();
}
inline void getAndLockServiceRequest::_internal_set_servicetype(int32_t value) {
  
  _impl_.servicetype_ = value;
}
inline void getAndLockServiceRequest::set_servicetype(int32_t value) {
  _internal_set_servicetype(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.getAndLockServiceRequest.serviceType)
}

// string clientUUID = 3;
inline void getAndLockServiceRequest::clear_clientuuid() {
  _impl_.clientuuid_.ClearToEmpty();
}
inline const std::string& getAndLockServiceRequest::clientuuid() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.getAndLockServiceRequest.clientUUID)
  return _internal_clientuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getAndLockServiceRequest::set_clientuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIServiceManager.getAndLockServiceRequest.clientUUID)
}
inline std::string* getAndLockServiceRequest::mutable_clientuuid() {
  std::string* _s = _internal_mutable_clientuuid();
  // @@protoc_insertion_point(field_mutable:grpcIServiceManager.getAndLockServiceRequest.clientUUID)
  return _s;
}
inline const std::string& getAndLockServiceRequest::_internal_clientuuid() const {
  return _impl_.clientuuid_.Get();
}
inline void getAndLockServiceRequest::_internal_set_clientuuid(const std::string& value) {
  
  _impl_.clientuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* getAndLockServiceRequest::_internal_mutable_clientuuid() {
  
  return _impl_.clientuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* getAndLockServiceRequest::release_clientuuid() {
  // @@protoc_insertion_point(field_release:grpcIServiceManager.getAndLockServiceRequest.clientUUID)
  return _impl_.clientuuid_.Release();
}
inline void getAndLockServiceRequest::set_allocated_clientuuid(std::string* clientuuid) {
  if (clientuuid != nullptr) {
    
  } else {
    
  }
  _impl_.clientuuid_.SetAllocated(clientuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientuuid_.IsDefault()) {
    _impl_.clientuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIServiceManager.getAndLockServiceRequest.clientUUID)
}

// string serviceURL = 4;
inline void getAndLockServiceRequest::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& getAndLockServiceRequest::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.getAndLockServiceRequest.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getAndLockServiceRequest::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIServiceManager.getAndLockServiceRequest.serviceURL)
}
inline std::string* getAndLockServiceRequest::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIServiceManager.getAndLockServiceRequest.serviceURL)
  return _s;
}
inline const std::string& getAndLockServiceRequest::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void getAndLockServiceRequest::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* getAndLockServiceRequest::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* getAndLockServiceRequest::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIServiceManager.getAndLockServiceRequest.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void getAndLockServiceRequest::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIServiceManager.getAndLockServiceRequest.serviceURL)
}

// -------------------------------------------------------------------

// getAndLockServiceResponse

// string serviceURL = 1;
inline void getAndLockServiceResponse::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& getAndLockServiceResponse::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.getAndLockServiceResponse.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getAndLockServiceResponse::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIServiceManager.getAndLockServiceResponse.serviceURL)
}
inline std::string* getAndLockServiceResponse::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIServiceManager.getAndLockServiceResponse.serviceURL)
  return _s;
}
inline const std::string& getAndLockServiceResponse::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void getAndLockServiceResponse::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* getAndLockServiceResponse::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* getAndLockServiceResponse::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIServiceManager.getAndLockServiceResponse.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void getAndLockServiceResponse::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIServiceManager.getAndLockServiceResponse.serviceURL)
}

// sint32 xpcfGrpcReturnValue = 2;
inline void getAndLockServiceResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t getAndLockServiceResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t getAndLockServiceResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.getAndLockServiceResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void getAndLockServiceResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void getAndLockServiceResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.getAndLockServiceResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// unlockServiceRequest

// int32 grpcServerCompressionFormat = 1;
inline void unlockServiceRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t unlockServiceRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t unlockServiceRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.unlockServiceRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void unlockServiceRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void unlockServiceRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.unlockServiceRequest.grpcServerCompressionFormat)
}

// sint32 serviceType = 2;
inline void unlockServiceRequest::clear_servicetype() {
  _impl_.servicetype_ = 0;
}
inline int32_t unlockServiceRequest::_internal_servicetype() const {
  return _impl_.servicetype_;
}
inline int32_t unlockServiceRequest::servicetype() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.unlockServiceRequest.serviceType)
  return _internal_servicetype();
}
inline void unlockServiceRequest::_internal_set_servicetype(int32_t value) {
  
  _impl_.servicetype_ = value;
}
inline void unlockServiceRequest::set_servicetype(int32_t value) {
  _internal_set_servicetype(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.unlockServiceRequest.serviceType)
}

// string clientUUID = 3;
inline void unlockServiceRequest::clear_clientuuid() {
  _impl_.clientuuid_.ClearToEmpty();
}
inline const std::string& unlockServiceRequest::clientuuid() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.unlockServiceRequest.clientUUID)
  return _internal_clientuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void unlockServiceRequest::set_clientuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIServiceManager.unlockServiceRequest.clientUUID)
}
inline std::string* unlockServiceRequest::mutable_clientuuid() {
  std::string* _s = _internal_mutable_clientuuid();
  // @@protoc_insertion_point(field_mutable:grpcIServiceManager.unlockServiceRequest.clientUUID)
  return _s;
}
inline const std::string& unlockServiceRequest::_internal_clientuuid() const {
  return _impl_.clientuuid_.Get();
}
inline void unlockServiceRequest::_internal_set_clientuuid(const std::string& value) {
  
  _impl_.clientuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* unlockServiceRequest::_internal_mutable_clientuuid() {
  
  return _impl_.clientuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* unlockServiceRequest::release_clientuuid() {
  // @@protoc_insertion_point(field_release:grpcIServiceManager.unlockServiceRequest.clientUUID)
  return _impl_.clientuuid_.Release();
}
inline void unlockServiceRequest::set_allocated_clientuuid(std::string* clientuuid) {
  if (clientuuid != nullptr) {
    
  } else {
    
  }
  _impl_.clientuuid_.SetAllocated(clientuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientuuid_.IsDefault()) {
    _impl_.clientuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIServiceManager.unlockServiceRequest.clientUUID)
}

// -------------------------------------------------------------------

// unlockServiceResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void unlockServiceResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t unlockServiceResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t unlockServiceResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIServiceManager.unlockServiceResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void unlockServiceResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void unlockServiceResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIServiceManager.unlockServiceResponse.xpcfGrpcReturnValue)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grpcIServiceManager

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_grpcIServiceManagerService_2eproto
