// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpcIMapManagerService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_grpcIMapManagerService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_grpcIMapManagerService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_grpcIMapManagerService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_grpcIMapManagerService_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_grpcIMapManagerService_2eproto;
namespace grpcIMapManager {
class createMapRequest;
struct createMapRequestDefaultTypeInternal;
extern createMapRequestDefaultTypeInternal _createMapRequest_default_instance_;
class createMapResponse;
struct createMapResponseDefaultTypeInternal;
extern createMapResponseDefaultTypeInternal _createMapResponse_default_instance_;
class decreaseMapClientsRequest;
struct decreaseMapClientsRequestDefaultTypeInternal;
extern decreaseMapClientsRequestDefaultTypeInternal _decreaseMapClientsRequest_default_instance_;
class decreaseMapClientsResponse;
struct decreaseMapClientsResponseDefaultTypeInternal;
extern decreaseMapClientsResponseDefaultTypeInternal _decreaseMapClientsResponse_default_instance_;
class deleteMapRequest;
struct deleteMapRequestDefaultTypeInternal;
extern deleteMapRequestDefaultTypeInternal _deleteMapRequest_default_instance_;
class deleteMapResponse;
struct deleteMapResponseDefaultTypeInternal;
extern deleteMapResponseDefaultTypeInternal _deleteMapResponse_default_instance_;
class getAllMapsRequest;
struct getAllMapsRequestDefaultTypeInternal;
extern getAllMapsRequestDefaultTypeInternal _getAllMapsRequest_default_instance_;
class getAllMapsResponse;
struct getAllMapsResponseDefaultTypeInternal;
extern getAllMapsResponseDefaultTypeInternal _getAllMapsResponse_default_instance_;
class increaseMapClientsRequest;
struct increaseMapClientsRequestDefaultTypeInternal;
extern increaseMapClientsRequestDefaultTypeInternal _increaseMapClientsRequest_default_instance_;
class increaseMapClientsResponse;
struct increaseMapClientsResponseDefaultTypeInternal;
extern increaseMapClientsResponseDefaultTypeInternal _increaseMapClientsResponse_default_instance_;
class initRequest;
struct initRequestDefaultTypeInternal;
extern initRequestDefaultTypeInternal _initRequest_default_instance_;
class initResponse;
struct initResponseDefaultTypeInternal;
extern initResponseDefaultTypeInternal _initResponse_default_instance_;
class registerMapUpdateServiceRequest;
struct registerMapUpdateServiceRequestDefaultTypeInternal;
extern registerMapUpdateServiceRequestDefaultTypeInternal _registerMapUpdateServiceRequest_default_instance_;
class registerMapUpdateServiceResponse;
struct registerMapUpdateServiceResponseDefaultTypeInternal;
extern registerMapUpdateServiceResponseDefaultTypeInternal _registerMapUpdateServiceResponse_default_instance_;
class unregisterMapUpdateServiceRequest;
struct unregisterMapUpdateServiceRequestDefaultTypeInternal;
extern unregisterMapUpdateServiceRequestDefaultTypeInternal _unregisterMapUpdateServiceRequest_default_instance_;
class unregisterMapUpdateServiceResponse;
struct unregisterMapUpdateServiceResponseDefaultTypeInternal;
extern unregisterMapUpdateServiceResponseDefaultTypeInternal _unregisterMapUpdateServiceResponse_default_instance_;
}  // namespace grpcIMapManager
PROTOBUF_NAMESPACE_OPEN
template<> ::grpcIMapManager::createMapRequest* Arena::CreateMaybeMessage<::grpcIMapManager::createMapRequest>(Arena*);
template<> ::grpcIMapManager::createMapResponse* Arena::CreateMaybeMessage<::grpcIMapManager::createMapResponse>(Arena*);
template<> ::grpcIMapManager::decreaseMapClientsRequest* Arena::CreateMaybeMessage<::grpcIMapManager::decreaseMapClientsRequest>(Arena*);
template<> ::grpcIMapManager::decreaseMapClientsResponse* Arena::CreateMaybeMessage<::grpcIMapManager::decreaseMapClientsResponse>(Arena*);
template<> ::grpcIMapManager::deleteMapRequest* Arena::CreateMaybeMessage<::grpcIMapManager::deleteMapRequest>(Arena*);
template<> ::grpcIMapManager::deleteMapResponse* Arena::CreateMaybeMessage<::grpcIMapManager::deleteMapResponse>(Arena*);
template<> ::grpcIMapManager::getAllMapsRequest* Arena::CreateMaybeMessage<::grpcIMapManager::getAllMapsRequest>(Arena*);
template<> ::grpcIMapManager::getAllMapsResponse* Arena::CreateMaybeMessage<::grpcIMapManager::getAllMapsResponse>(Arena*);
template<> ::grpcIMapManager::increaseMapClientsRequest* Arena::CreateMaybeMessage<::grpcIMapManager::increaseMapClientsRequest>(Arena*);
template<> ::grpcIMapManager::increaseMapClientsResponse* Arena::CreateMaybeMessage<::grpcIMapManager::increaseMapClientsResponse>(Arena*);
template<> ::grpcIMapManager::initRequest* Arena::CreateMaybeMessage<::grpcIMapManager::initRequest>(Arena*);
template<> ::grpcIMapManager::initResponse* Arena::CreateMaybeMessage<::grpcIMapManager::initResponse>(Arena*);
template<> ::grpcIMapManager::registerMapUpdateServiceRequest* Arena::CreateMaybeMessage<::grpcIMapManager::registerMapUpdateServiceRequest>(Arena*);
template<> ::grpcIMapManager::registerMapUpdateServiceResponse* Arena::CreateMaybeMessage<::grpcIMapManager::registerMapUpdateServiceResponse>(Arena*);
template<> ::grpcIMapManager::unregisterMapUpdateServiceRequest* Arena::CreateMaybeMessage<::grpcIMapManager::unregisterMapUpdateServiceRequest>(Arena*);
template<> ::grpcIMapManager::unregisterMapUpdateServiceResponse* Arena::CreateMaybeMessage<::grpcIMapManager::unregisterMapUpdateServiceResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace grpcIMapManager {

// ===================================================================

class initRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.initRequest) */ {
 public:
  inline initRequest() : initRequest(nullptr) {}
  ~initRequest() override;
  explicit PROTOBUF_CONSTEXPR initRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  initRequest(const initRequest& from);
  initRequest(initRequest&& from) noexcept
    : initRequest() {
    *this = ::std::move(from);
  }

  inline initRequest& operator=(const initRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline initRequest& operator=(initRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const initRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const initRequest* internal_default_instance() {
    return reinterpret_cast<const initRequest*>(
               &_initRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(initRequest& a, initRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(initRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(initRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  initRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<initRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const initRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const initRequest& from) {
    initRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(initRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.initRequest";
  }
  protected:
  explicit initRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.initRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class initResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.initResponse) */ {
 public:
  inline initResponse() : initResponse(nullptr) {}
  ~initResponse() override;
  explicit PROTOBUF_CONSTEXPR initResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  initResponse(const initResponse& from);
  initResponse(initResponse&& from) noexcept
    : initResponse() {
    *this = ::std::move(from);
  }

  inline initResponse& operator=(const initResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline initResponse& operator=(initResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const initResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const initResponse* internal_default_instance() {
    return reinterpret_cast<const initResponse*>(
               &_initResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(initResponse& a, initResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(initResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(initResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  initResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<initResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const initResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const initResponse& from) {
    initResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(initResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.initResponse";
  }
  protected:
  explicit initResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.initResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class createMapRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.createMapRequest) */ {
 public:
  inline createMapRequest() : createMapRequest(nullptr) {}
  ~createMapRequest() override;
  explicit PROTOBUF_CONSTEXPR createMapRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createMapRequest(const createMapRequest& from);
  createMapRequest(createMapRequest&& from) noexcept
    : createMapRequest() {
    *this = ::std::move(from);
  }

  inline createMapRequest& operator=(const createMapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline createMapRequest& operator=(createMapRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createMapRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const createMapRequest* internal_default_instance() {
    return reinterpret_cast<const createMapRequest*>(
               &_createMapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(createMapRequest& a, createMapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(createMapRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createMapRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createMapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createMapRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const createMapRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const createMapRequest& from) {
    createMapRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(createMapRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.createMapRequest";
  }
  protected:
  explicit createMapRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.createMapRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class createMapResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.createMapResponse) */ {
 public:
  inline createMapResponse() : createMapResponse(nullptr) {}
  ~createMapResponse() override;
  explicit PROTOBUF_CONSTEXPR createMapResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createMapResponse(const createMapResponse& from);
  createMapResponse(createMapResponse&& from) noexcept
    : createMapResponse() {
    *this = ::std::move(from);
  }

  inline createMapResponse& operator=(const createMapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline createMapResponse& operator=(createMapResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createMapResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const createMapResponse* internal_default_instance() {
    return reinterpret_cast<const createMapResponse*>(
               &_createMapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(createMapResponse& a, createMapResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(createMapResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createMapResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createMapResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createMapResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const createMapResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const createMapResponse& from) {
    createMapResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(createMapResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.createMapResponse";
  }
  protected:
  explicit createMapResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.createMapResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class deleteMapRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.deleteMapRequest) */ {
 public:
  inline deleteMapRequest() : deleteMapRequest(nullptr) {}
  ~deleteMapRequest() override;
  explicit PROTOBUF_CONSTEXPR deleteMapRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  deleteMapRequest(const deleteMapRequest& from);
  deleteMapRequest(deleteMapRequest&& from) noexcept
    : deleteMapRequest() {
    *this = ::std::move(from);
  }

  inline deleteMapRequest& operator=(const deleteMapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline deleteMapRequest& operator=(deleteMapRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const deleteMapRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const deleteMapRequest* internal_default_instance() {
    return reinterpret_cast<const deleteMapRequest*>(
               &_deleteMapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(deleteMapRequest& a, deleteMapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(deleteMapRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deleteMapRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  deleteMapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<deleteMapRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const deleteMapRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const deleteMapRequest& from) {
    deleteMapRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deleteMapRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.deleteMapRequest";
  }
  protected:
  explicit deleteMapRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.deleteMapRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class deleteMapResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.deleteMapResponse) */ {
 public:
  inline deleteMapResponse() : deleteMapResponse(nullptr) {}
  ~deleteMapResponse() override;
  explicit PROTOBUF_CONSTEXPR deleteMapResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  deleteMapResponse(const deleteMapResponse& from);
  deleteMapResponse(deleteMapResponse&& from) noexcept
    : deleteMapResponse() {
    *this = ::std::move(from);
  }

  inline deleteMapResponse& operator=(const deleteMapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline deleteMapResponse& operator=(deleteMapResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const deleteMapResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const deleteMapResponse* internal_default_instance() {
    return reinterpret_cast<const deleteMapResponse*>(
               &_deleteMapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(deleteMapResponse& a, deleteMapResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(deleteMapResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deleteMapResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  deleteMapResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<deleteMapResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const deleteMapResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const deleteMapResponse& from) {
    deleteMapResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deleteMapResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.deleteMapResponse";
  }
  protected:
  explicit deleteMapResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.deleteMapResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class getAllMapsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.getAllMapsRequest) */ {
 public:
  inline getAllMapsRequest() : getAllMapsRequest(nullptr) {}
  ~getAllMapsRequest() override;
  explicit PROTOBUF_CONSTEXPR getAllMapsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getAllMapsRequest(const getAllMapsRequest& from);
  getAllMapsRequest(getAllMapsRequest&& from) noexcept
    : getAllMapsRequest() {
    *this = ::std::move(from);
  }

  inline getAllMapsRequest& operator=(const getAllMapsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline getAllMapsRequest& operator=(getAllMapsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getAllMapsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const getAllMapsRequest* internal_default_instance() {
    return reinterpret_cast<const getAllMapsRequest*>(
               &_getAllMapsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(getAllMapsRequest& a, getAllMapsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(getAllMapsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getAllMapsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getAllMapsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getAllMapsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getAllMapsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getAllMapsRequest& from) {
    getAllMapsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getAllMapsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.getAllMapsRequest";
  }
  protected:
  explicit getAllMapsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDListFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // bytes mapUUIDList = 2;
  void clear_mapuuidlist();
  const std::string& mapuuidlist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuidlist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuidlist();
  PROTOBUF_NODISCARD std::string* release_mapuuidlist();
  void set_allocated_mapuuidlist(std::string* mapuuidlist);
  private:
  const std::string& _internal_mapuuidlist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuidlist(const std::string& value);
  std::string* _internal_mutable_mapuuidlist();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.getAllMapsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuidlist_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class getAllMapsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.getAllMapsResponse) */ {
 public:
  inline getAllMapsResponse() : getAllMapsResponse(nullptr) {}
  ~getAllMapsResponse() override;
  explicit PROTOBUF_CONSTEXPR getAllMapsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getAllMapsResponse(const getAllMapsResponse& from);
  getAllMapsResponse(getAllMapsResponse&& from) noexcept
    : getAllMapsResponse() {
    *this = ::std::move(from);
  }

  inline getAllMapsResponse& operator=(const getAllMapsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline getAllMapsResponse& operator=(getAllMapsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getAllMapsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const getAllMapsResponse* internal_default_instance() {
    return reinterpret_cast<const getAllMapsResponse*>(
               &_getAllMapsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(getAllMapsResponse& a, getAllMapsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(getAllMapsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getAllMapsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getAllMapsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getAllMapsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getAllMapsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getAllMapsResponse& from) {
    getAllMapsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getAllMapsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.getAllMapsResponse";
  }
  protected:
  explicit getAllMapsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDListFieldNumber = 1,
    kXpcfGrpcReturnValueFieldNumber = 2,
  };
  // bytes mapUUIDList = 1;
  void clear_mapuuidlist();
  const std::string& mapuuidlist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuidlist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuidlist();
  PROTOBUF_NODISCARD std::string* release_mapuuidlist();
  void set_allocated_mapuuidlist(std::string* mapuuidlist);
  private:
  const std::string& _internal_mapuuidlist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuidlist(const std::string& value);
  std::string* _internal_mutable_mapuuidlist();
  public:

  // sint32 xpcfGrpcReturnValue = 2;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.getAllMapsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuidlist_;
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class registerMapUpdateServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.registerMapUpdateServiceRequest) */ {
 public:
  inline registerMapUpdateServiceRequest() : registerMapUpdateServiceRequest(nullptr) {}
  ~registerMapUpdateServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR registerMapUpdateServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  registerMapUpdateServiceRequest(const registerMapUpdateServiceRequest& from);
  registerMapUpdateServiceRequest(registerMapUpdateServiceRequest&& from) noexcept
    : registerMapUpdateServiceRequest() {
    *this = ::std::move(from);
  }

  inline registerMapUpdateServiceRequest& operator=(const registerMapUpdateServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline registerMapUpdateServiceRequest& operator=(registerMapUpdateServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const registerMapUpdateServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const registerMapUpdateServiceRequest* internal_default_instance() {
    return reinterpret_cast<const registerMapUpdateServiceRequest*>(
               &_registerMapUpdateServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(registerMapUpdateServiceRequest& a, registerMapUpdateServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(registerMapUpdateServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(registerMapUpdateServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  registerMapUpdateServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<registerMapUpdateServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const registerMapUpdateServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const registerMapUpdateServiceRequest& from) {
    registerMapUpdateServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(registerMapUpdateServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.registerMapUpdateServiceRequest";
  }
  protected:
  explicit registerMapUpdateServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceURLFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string serviceURL = 2;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.registerMapUpdateServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class registerMapUpdateServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.registerMapUpdateServiceResponse) */ {
 public:
  inline registerMapUpdateServiceResponse() : registerMapUpdateServiceResponse(nullptr) {}
  ~registerMapUpdateServiceResponse() override;
  explicit PROTOBUF_CONSTEXPR registerMapUpdateServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  registerMapUpdateServiceResponse(const registerMapUpdateServiceResponse& from);
  registerMapUpdateServiceResponse(registerMapUpdateServiceResponse&& from) noexcept
    : registerMapUpdateServiceResponse() {
    *this = ::std::move(from);
  }

  inline registerMapUpdateServiceResponse& operator=(const registerMapUpdateServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline registerMapUpdateServiceResponse& operator=(registerMapUpdateServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const registerMapUpdateServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const registerMapUpdateServiceResponse* internal_default_instance() {
    return reinterpret_cast<const registerMapUpdateServiceResponse*>(
               &_registerMapUpdateServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(registerMapUpdateServiceResponse& a, registerMapUpdateServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(registerMapUpdateServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(registerMapUpdateServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  registerMapUpdateServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<registerMapUpdateServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const registerMapUpdateServiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const registerMapUpdateServiceResponse& from) {
    registerMapUpdateServiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(registerMapUpdateServiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.registerMapUpdateServiceResponse";
  }
  protected:
  explicit registerMapUpdateServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.registerMapUpdateServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class unregisterMapUpdateServiceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.unregisterMapUpdateServiceRequest) */ {
 public:
  inline unregisterMapUpdateServiceRequest() : unregisterMapUpdateServiceRequest(nullptr) {}
  ~unregisterMapUpdateServiceRequest() override;
  explicit PROTOBUF_CONSTEXPR unregisterMapUpdateServiceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  unregisterMapUpdateServiceRequest(const unregisterMapUpdateServiceRequest& from);
  unregisterMapUpdateServiceRequest(unregisterMapUpdateServiceRequest&& from) noexcept
    : unregisterMapUpdateServiceRequest() {
    *this = ::std::move(from);
  }

  inline unregisterMapUpdateServiceRequest& operator=(const unregisterMapUpdateServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline unregisterMapUpdateServiceRequest& operator=(unregisterMapUpdateServiceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const unregisterMapUpdateServiceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const unregisterMapUpdateServiceRequest* internal_default_instance() {
    return reinterpret_cast<const unregisterMapUpdateServiceRequest*>(
               &_unregisterMapUpdateServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(unregisterMapUpdateServiceRequest& a, unregisterMapUpdateServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(unregisterMapUpdateServiceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(unregisterMapUpdateServiceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  unregisterMapUpdateServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<unregisterMapUpdateServiceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const unregisterMapUpdateServiceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const unregisterMapUpdateServiceRequest& from) {
    unregisterMapUpdateServiceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(unregisterMapUpdateServiceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.unregisterMapUpdateServiceRequest";
  }
  protected:
  explicit unregisterMapUpdateServiceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceURLFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string serviceURL = 2;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.unregisterMapUpdateServiceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class unregisterMapUpdateServiceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.unregisterMapUpdateServiceResponse) */ {
 public:
  inline unregisterMapUpdateServiceResponse() : unregisterMapUpdateServiceResponse(nullptr) {}
  ~unregisterMapUpdateServiceResponse() override;
  explicit PROTOBUF_CONSTEXPR unregisterMapUpdateServiceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  unregisterMapUpdateServiceResponse(const unregisterMapUpdateServiceResponse& from);
  unregisterMapUpdateServiceResponse(unregisterMapUpdateServiceResponse&& from) noexcept
    : unregisterMapUpdateServiceResponse() {
    *this = ::std::move(from);
  }

  inline unregisterMapUpdateServiceResponse& operator=(const unregisterMapUpdateServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline unregisterMapUpdateServiceResponse& operator=(unregisterMapUpdateServiceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const unregisterMapUpdateServiceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const unregisterMapUpdateServiceResponse* internal_default_instance() {
    return reinterpret_cast<const unregisterMapUpdateServiceResponse*>(
               &_unregisterMapUpdateServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(unregisterMapUpdateServiceResponse& a, unregisterMapUpdateServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(unregisterMapUpdateServiceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(unregisterMapUpdateServiceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  unregisterMapUpdateServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<unregisterMapUpdateServiceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const unregisterMapUpdateServiceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const unregisterMapUpdateServiceResponse& from) {
    unregisterMapUpdateServiceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(unregisterMapUpdateServiceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.unregisterMapUpdateServiceResponse";
  }
  protected:
  explicit unregisterMapUpdateServiceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.unregisterMapUpdateServiceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class increaseMapClientsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.increaseMapClientsRequest) */ {
 public:
  inline increaseMapClientsRequest() : increaseMapClientsRequest(nullptr) {}
  ~increaseMapClientsRequest() override;
  explicit PROTOBUF_CONSTEXPR increaseMapClientsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  increaseMapClientsRequest(const increaseMapClientsRequest& from);
  increaseMapClientsRequest(increaseMapClientsRequest&& from) noexcept
    : increaseMapClientsRequest() {
    *this = ::std::move(from);
  }

  inline increaseMapClientsRequest& operator=(const increaseMapClientsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline increaseMapClientsRequest& operator=(increaseMapClientsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const increaseMapClientsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const increaseMapClientsRequest* internal_default_instance() {
    return reinterpret_cast<const increaseMapClientsRequest*>(
               &_increaseMapClientsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(increaseMapClientsRequest& a, increaseMapClientsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(increaseMapClientsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(increaseMapClientsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  increaseMapClientsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<increaseMapClientsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const increaseMapClientsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const increaseMapClientsRequest& from) {
    increaseMapClientsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(increaseMapClientsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.increaseMapClientsRequest";
  }
  protected:
  explicit increaseMapClientsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kServiceURLFieldNumber = 3,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // string serviceURL = 3;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.increaseMapClientsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class increaseMapClientsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.increaseMapClientsResponse) */ {
 public:
  inline increaseMapClientsResponse() : increaseMapClientsResponse(nullptr) {}
  ~increaseMapClientsResponse() override;
  explicit PROTOBUF_CONSTEXPR increaseMapClientsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  increaseMapClientsResponse(const increaseMapClientsResponse& from);
  increaseMapClientsResponse(increaseMapClientsResponse&& from) noexcept
    : increaseMapClientsResponse() {
    *this = ::std::move(from);
  }

  inline increaseMapClientsResponse& operator=(const increaseMapClientsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline increaseMapClientsResponse& operator=(increaseMapClientsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const increaseMapClientsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const increaseMapClientsResponse* internal_default_instance() {
    return reinterpret_cast<const increaseMapClientsResponse*>(
               &_increaseMapClientsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(increaseMapClientsResponse& a, increaseMapClientsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(increaseMapClientsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(increaseMapClientsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  increaseMapClientsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<increaseMapClientsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const increaseMapClientsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const increaseMapClientsResponse& from) {
    increaseMapClientsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(increaseMapClientsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.increaseMapClientsResponse";
  }
  protected:
  explicit increaseMapClientsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceURLFieldNumber = 1,
    kXpcfGrpcReturnValueFieldNumber = 2,
  };
  // string serviceURL = 1;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // sint32 xpcfGrpcReturnValue = 2;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.increaseMapClientsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class decreaseMapClientsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.decreaseMapClientsRequest) */ {
 public:
  inline decreaseMapClientsRequest() : decreaseMapClientsRequest(nullptr) {}
  ~decreaseMapClientsRequest() override;
  explicit PROTOBUF_CONSTEXPR decreaseMapClientsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  decreaseMapClientsRequest(const decreaseMapClientsRequest& from);
  decreaseMapClientsRequest(decreaseMapClientsRequest&& from) noexcept
    : decreaseMapClientsRequest() {
    *this = ::std::move(from);
  }

  inline decreaseMapClientsRequest& operator=(const decreaseMapClientsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline decreaseMapClientsRequest& operator=(decreaseMapClientsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const decreaseMapClientsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const decreaseMapClientsRequest* internal_default_instance() {
    return reinterpret_cast<const decreaseMapClientsRequest*>(
               &_decreaseMapClientsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(decreaseMapClientsRequest& a, decreaseMapClientsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(decreaseMapClientsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(decreaseMapClientsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  decreaseMapClientsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<decreaseMapClientsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const decreaseMapClientsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const decreaseMapClientsRequest& from) {
    decreaseMapClientsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(decreaseMapClientsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.decreaseMapClientsRequest";
  }
  protected:
  explicit decreaseMapClientsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.decreaseMapClientsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// -------------------------------------------------------------------

class decreaseMapClientsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapManager.decreaseMapClientsResponse) */ {
 public:
  inline decreaseMapClientsResponse() : decreaseMapClientsResponse(nullptr) {}
  ~decreaseMapClientsResponse() override;
  explicit PROTOBUF_CONSTEXPR decreaseMapClientsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  decreaseMapClientsResponse(const decreaseMapClientsResponse& from);
  decreaseMapClientsResponse(decreaseMapClientsResponse&& from) noexcept
    : decreaseMapClientsResponse() {
    *this = ::std::move(from);
  }

  inline decreaseMapClientsResponse& operator=(const decreaseMapClientsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline decreaseMapClientsResponse& operator=(decreaseMapClientsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const decreaseMapClientsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const decreaseMapClientsResponse* internal_default_instance() {
    return reinterpret_cast<const decreaseMapClientsResponse*>(
               &_decreaseMapClientsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(decreaseMapClientsResponse& a, decreaseMapClientsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(decreaseMapClientsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(decreaseMapClientsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  decreaseMapClientsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<decreaseMapClientsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const decreaseMapClientsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const decreaseMapClientsResponse& from) {
    decreaseMapClientsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(decreaseMapClientsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapManager.decreaseMapClientsResponse";
  }
  protected:
  explicit decreaseMapClientsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapManager.decreaseMapClientsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapManagerService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// initRequest

// int32 grpcServerCompressionFormat = 1;
inline void initRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t initRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t initRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.initRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void initRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void initRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.initRequest.grpcServerCompressionFormat)
}

// -------------------------------------------------------------------

// initResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void initResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t initResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t initResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.initResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void initResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void initResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.initResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// createMapRequest

// int32 grpcServerCompressionFormat = 1;
inline void createMapRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t createMapRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t createMapRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.createMapRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void createMapRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void createMapRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.createMapRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void createMapRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& createMapRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.createMapRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void createMapRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapManager.createMapRequest.mapUUID)
}
inline std::string* createMapRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapManager.createMapRequest.mapUUID)
  return _s;
}
inline const std::string& createMapRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void createMapRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* createMapRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* createMapRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapManager.createMapRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void createMapRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapManager.createMapRequest.mapUUID)
}

// -------------------------------------------------------------------

// createMapResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void createMapResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t createMapResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t createMapResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.createMapResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void createMapResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void createMapResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.createMapResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// deleteMapRequest

// int32 grpcServerCompressionFormat = 1;
inline void deleteMapRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t deleteMapRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t deleteMapRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.deleteMapRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void deleteMapRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void deleteMapRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.deleteMapRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void deleteMapRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& deleteMapRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.deleteMapRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteMapRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapManager.deleteMapRequest.mapUUID)
}
inline std::string* deleteMapRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapManager.deleteMapRequest.mapUUID)
  return _s;
}
inline const std::string& deleteMapRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void deleteMapRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteMapRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteMapRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapManager.deleteMapRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void deleteMapRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapManager.deleteMapRequest.mapUUID)
}

// -------------------------------------------------------------------

// deleteMapResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void deleteMapResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t deleteMapResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t deleteMapResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.deleteMapResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void deleteMapResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void deleteMapResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.deleteMapResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// getAllMapsRequest

// int32 grpcServerCompressionFormat = 1;
inline void getAllMapsRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t getAllMapsRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t getAllMapsRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.getAllMapsRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void getAllMapsRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void getAllMapsRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.getAllMapsRequest.grpcServerCompressionFormat)
}

// bytes mapUUIDList = 2;
inline void getAllMapsRequest::clear_mapuuidlist() {
  _impl_.mapuuidlist_.ClearToEmpty();
}
inline const std::string& getAllMapsRequest::mapuuidlist() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.getAllMapsRequest.mapUUIDList)
  return _internal_mapuuidlist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getAllMapsRequest::set_mapuuidlist(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuidlist_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapManager.getAllMapsRequest.mapUUIDList)
}
inline std::string* getAllMapsRequest::mutable_mapuuidlist() {
  std::string* _s = _internal_mutable_mapuuidlist();
  // @@protoc_insertion_point(field_mutable:grpcIMapManager.getAllMapsRequest.mapUUIDList)
  return _s;
}
inline const std::string& getAllMapsRequest::_internal_mapuuidlist() const {
  return _impl_.mapuuidlist_.Get();
}
inline void getAllMapsRequest::_internal_set_mapuuidlist(const std::string& value) {
  
  _impl_.mapuuidlist_.Set(value, GetArenaForAllocation());
}
inline std::string* getAllMapsRequest::_internal_mutable_mapuuidlist() {
  
  return _impl_.mapuuidlist_.Mutable(GetArenaForAllocation());
}
inline std::string* getAllMapsRequest::release_mapuuidlist() {
  // @@protoc_insertion_point(field_release:grpcIMapManager.getAllMapsRequest.mapUUIDList)
  return _impl_.mapuuidlist_.Release();
}
inline void getAllMapsRequest::set_allocated_mapuuidlist(std::string* mapuuidlist) {
  if (mapuuidlist != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuidlist_.SetAllocated(mapuuidlist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuidlist_.IsDefault()) {
    _impl_.mapuuidlist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapManager.getAllMapsRequest.mapUUIDList)
}

// -------------------------------------------------------------------

// getAllMapsResponse

// bytes mapUUIDList = 1;
inline void getAllMapsResponse::clear_mapuuidlist() {
  _impl_.mapuuidlist_.ClearToEmpty();
}
inline const std::string& getAllMapsResponse::mapuuidlist() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.getAllMapsResponse.mapUUIDList)
  return _internal_mapuuidlist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getAllMapsResponse::set_mapuuidlist(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuidlist_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapManager.getAllMapsResponse.mapUUIDList)
}
inline std::string* getAllMapsResponse::mutable_mapuuidlist() {
  std::string* _s = _internal_mutable_mapuuidlist();
  // @@protoc_insertion_point(field_mutable:grpcIMapManager.getAllMapsResponse.mapUUIDList)
  return _s;
}
inline const std::string& getAllMapsResponse::_internal_mapuuidlist() const {
  return _impl_.mapuuidlist_.Get();
}
inline void getAllMapsResponse::_internal_set_mapuuidlist(const std::string& value) {
  
  _impl_.mapuuidlist_.Set(value, GetArenaForAllocation());
}
inline std::string* getAllMapsResponse::_internal_mutable_mapuuidlist() {
  
  return _impl_.mapuuidlist_.Mutable(GetArenaForAllocation());
}
inline std::string* getAllMapsResponse::release_mapuuidlist() {
  // @@protoc_insertion_point(field_release:grpcIMapManager.getAllMapsResponse.mapUUIDList)
  return _impl_.mapuuidlist_.Release();
}
inline void getAllMapsResponse::set_allocated_mapuuidlist(std::string* mapuuidlist) {
  if (mapuuidlist != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuidlist_.SetAllocated(mapuuidlist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuidlist_.IsDefault()) {
    _impl_.mapuuidlist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapManager.getAllMapsResponse.mapUUIDList)
}

// sint32 xpcfGrpcReturnValue = 2;
inline void getAllMapsResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t getAllMapsResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t getAllMapsResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.getAllMapsResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void getAllMapsResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void getAllMapsResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.getAllMapsResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// registerMapUpdateServiceRequest

// int32 grpcServerCompressionFormat = 1;
inline void registerMapUpdateServiceRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t registerMapUpdateServiceRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t registerMapUpdateServiceRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.registerMapUpdateServiceRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void registerMapUpdateServiceRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void registerMapUpdateServiceRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.registerMapUpdateServiceRequest.grpcServerCompressionFormat)
}

// string serviceURL = 2;
inline void registerMapUpdateServiceRequest::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& registerMapUpdateServiceRequest::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.registerMapUpdateServiceRequest.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void registerMapUpdateServiceRequest::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapManager.registerMapUpdateServiceRequest.serviceURL)
}
inline std::string* registerMapUpdateServiceRequest::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIMapManager.registerMapUpdateServiceRequest.serviceURL)
  return _s;
}
inline const std::string& registerMapUpdateServiceRequest::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void registerMapUpdateServiceRequest::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* registerMapUpdateServiceRequest::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* registerMapUpdateServiceRequest::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIMapManager.registerMapUpdateServiceRequest.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void registerMapUpdateServiceRequest::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapManager.registerMapUpdateServiceRequest.serviceURL)
}

// -------------------------------------------------------------------

// registerMapUpdateServiceResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void registerMapUpdateServiceResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t registerMapUpdateServiceResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t registerMapUpdateServiceResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.registerMapUpdateServiceResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void registerMapUpdateServiceResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void registerMapUpdateServiceResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.registerMapUpdateServiceResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// unregisterMapUpdateServiceRequest

// int32 grpcServerCompressionFormat = 1;
inline void unregisterMapUpdateServiceRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t unregisterMapUpdateServiceRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t unregisterMapUpdateServiceRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.unregisterMapUpdateServiceRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void unregisterMapUpdateServiceRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void unregisterMapUpdateServiceRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.unregisterMapUpdateServiceRequest.grpcServerCompressionFormat)
}

// string serviceURL = 2;
inline void unregisterMapUpdateServiceRequest::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& unregisterMapUpdateServiceRequest::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.unregisterMapUpdateServiceRequest.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void unregisterMapUpdateServiceRequest::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapManager.unregisterMapUpdateServiceRequest.serviceURL)
}
inline std::string* unregisterMapUpdateServiceRequest::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIMapManager.unregisterMapUpdateServiceRequest.serviceURL)
  return _s;
}
inline const std::string& unregisterMapUpdateServiceRequest::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void unregisterMapUpdateServiceRequest::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* unregisterMapUpdateServiceRequest::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* unregisterMapUpdateServiceRequest::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIMapManager.unregisterMapUpdateServiceRequest.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void unregisterMapUpdateServiceRequest::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapManager.unregisterMapUpdateServiceRequest.serviceURL)
}

// -------------------------------------------------------------------

// unregisterMapUpdateServiceResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void unregisterMapUpdateServiceResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t unregisterMapUpdateServiceResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t unregisterMapUpdateServiceResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.unregisterMapUpdateServiceResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void unregisterMapUpdateServiceResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void unregisterMapUpdateServiceResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.unregisterMapUpdateServiceResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// increaseMapClientsRequest

// int32 grpcServerCompressionFormat = 1;
inline void increaseMapClientsRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t increaseMapClientsRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t increaseMapClientsRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.increaseMapClientsRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void increaseMapClientsRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void increaseMapClientsRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.increaseMapClientsRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void increaseMapClientsRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& increaseMapClientsRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.increaseMapClientsRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void increaseMapClientsRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapManager.increaseMapClientsRequest.mapUUID)
}
inline std::string* increaseMapClientsRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapManager.increaseMapClientsRequest.mapUUID)
  return _s;
}
inline const std::string& increaseMapClientsRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void increaseMapClientsRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* increaseMapClientsRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* increaseMapClientsRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapManager.increaseMapClientsRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void increaseMapClientsRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapManager.increaseMapClientsRequest.mapUUID)
}

// string serviceURL = 3;
inline void increaseMapClientsRequest::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& increaseMapClientsRequest::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.increaseMapClientsRequest.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void increaseMapClientsRequest::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapManager.increaseMapClientsRequest.serviceURL)
}
inline std::string* increaseMapClientsRequest::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIMapManager.increaseMapClientsRequest.serviceURL)
  return _s;
}
inline const std::string& increaseMapClientsRequest::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void increaseMapClientsRequest::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* increaseMapClientsRequest::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* increaseMapClientsRequest::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIMapManager.increaseMapClientsRequest.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void increaseMapClientsRequest::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapManager.increaseMapClientsRequest.serviceURL)
}

// -------------------------------------------------------------------

// increaseMapClientsResponse

// string serviceURL = 1;
inline void increaseMapClientsResponse::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& increaseMapClientsResponse::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.increaseMapClientsResponse.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void increaseMapClientsResponse::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapManager.increaseMapClientsResponse.serviceURL)
}
inline std::string* increaseMapClientsResponse::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIMapManager.increaseMapClientsResponse.serviceURL)
  return _s;
}
inline const std::string& increaseMapClientsResponse::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void increaseMapClientsResponse::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* increaseMapClientsResponse::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* increaseMapClientsResponse::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIMapManager.increaseMapClientsResponse.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void increaseMapClientsResponse::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapManager.increaseMapClientsResponse.serviceURL)
}

// sint32 xpcfGrpcReturnValue = 2;
inline void increaseMapClientsResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t increaseMapClientsResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t increaseMapClientsResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.increaseMapClientsResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void increaseMapClientsResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void increaseMapClientsResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.increaseMapClientsResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// decreaseMapClientsRequest

// int32 grpcServerCompressionFormat = 1;
inline void decreaseMapClientsRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t decreaseMapClientsRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t decreaseMapClientsRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.decreaseMapClientsRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void decreaseMapClientsRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void decreaseMapClientsRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.decreaseMapClientsRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void decreaseMapClientsRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& decreaseMapClientsRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.decreaseMapClientsRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void decreaseMapClientsRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapManager.decreaseMapClientsRequest.mapUUID)
}
inline std::string* decreaseMapClientsRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapManager.decreaseMapClientsRequest.mapUUID)
  return _s;
}
inline const std::string& decreaseMapClientsRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void decreaseMapClientsRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* decreaseMapClientsRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* decreaseMapClientsRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapManager.decreaseMapClientsRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void decreaseMapClientsRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapManager.decreaseMapClientsRequest.mapUUID)
}

// -------------------------------------------------------------------

// decreaseMapClientsResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void decreaseMapClientsResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t decreaseMapClientsResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t decreaseMapClientsResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapManager.decreaseMapClientsResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void decreaseMapClientsResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void decreaseMapClientsResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapManager.decreaseMapClientsResponse.xpcfGrpcReturnValue)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grpcIMapManager

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_grpcIMapManagerService_2eproto
