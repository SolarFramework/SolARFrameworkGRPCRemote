// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpcIMapsManagerService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_grpcIMapsManagerService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_grpcIMapsManagerService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_grpcIMapsManagerService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_grpcIMapsManagerService_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_grpcIMapsManagerService_2eproto;
namespace grpcIMapsManager {
class createMapRequest;
struct createMapRequestDefaultTypeInternal;
extern createMapRequestDefaultTypeInternal _createMapRequest_default_instance_;
class createMapResponse;
struct createMapResponseDefaultTypeInternal;
extern createMapResponseDefaultTypeInternal _createMapResponse_default_instance_;
class decreaseMapClientsRequest;
struct decreaseMapClientsRequestDefaultTypeInternal;
extern decreaseMapClientsRequestDefaultTypeInternal _decreaseMapClientsRequest_default_instance_;
class decreaseMapClientsResponse;
struct decreaseMapClientsResponseDefaultTypeInternal;
extern decreaseMapClientsResponseDefaultTypeInternal _decreaseMapClientsResponse_default_instance_;
class deleteMapRequest;
struct deleteMapRequestDefaultTypeInternal;
extern deleteMapRequestDefaultTypeInternal _deleteMapRequest_default_instance_;
class deleteMapResponse;
struct deleteMapResponseDefaultTypeInternal;
extern deleteMapResponseDefaultTypeInternal _deleteMapResponse_default_instance_;
class getAllMapsRequest;
struct getAllMapsRequestDefaultTypeInternal;
extern getAllMapsRequestDefaultTypeInternal _getAllMapsRequest_default_instance_;
class getAllMapsResponse;
struct getAllMapsResponseDefaultTypeInternal;
extern getAllMapsResponseDefaultTypeInternal _getAllMapsResponse_default_instance_;
class getMapInfoRequest;
struct getMapInfoRequestDefaultTypeInternal;
extern getMapInfoRequestDefaultTypeInternal _getMapInfoRequest_default_instance_;
class getMapInfoResponse;
struct getMapInfoResponseDefaultTypeInternal;
extern getMapInfoResponseDefaultTypeInternal _getMapInfoResponse_default_instance_;
class getMapProcessingDataRequest;
struct getMapProcessingDataRequestDefaultTypeInternal;
extern getMapProcessingDataRequestDefaultTypeInternal _getMapProcessingDataRequest_default_instance_;
class getMapProcessingDataResponse;
struct getMapProcessingDataResponseDefaultTypeInternal;
extern getMapProcessingDataResponseDefaultTypeInternal _getMapProcessingDataResponse_default_instance_;
class getMapProcessingStatusRequest;
struct getMapProcessingStatusRequestDefaultTypeInternal;
extern getMapProcessingStatusRequestDefaultTypeInternal _getMapProcessingStatusRequest_default_instance_;
class getMapProcessingStatusResponse;
struct getMapProcessingStatusResponseDefaultTypeInternal;
extern getMapProcessingStatusResponseDefaultTypeInternal _getMapProcessingStatusResponse_default_instance_;
class getMapRequestRequest;
struct getMapRequestRequestDefaultTypeInternal;
extern getMapRequestRequestDefaultTypeInternal _getMapRequestRequest_default_instance_;
class getMapRequestResponse;
struct getMapRequestResponseDefaultTypeInternal;
extern getMapRequestResponseDefaultTypeInternal _getMapRequestResponse_default_instance_;
class getPointCloudRequestRequest;
struct getPointCloudRequestRequestDefaultTypeInternal;
extern getPointCloudRequestRequestDefaultTypeInternal _getPointCloudRequestRequest_default_instance_;
class getPointCloudRequestResponse;
struct getPointCloudRequestResponseDefaultTypeInternal;
extern getPointCloudRequestResponseDefaultTypeInternal _getPointCloudRequestResponse_default_instance_;
class increaseMapClientsRequest;
struct increaseMapClientsRequestDefaultTypeInternal;
extern increaseMapClientsRequestDefaultTypeInternal _increaseMapClientsRequest_default_instance_;
class increaseMapClientsResponse;
struct increaseMapClientsResponseDefaultTypeInternal;
extern increaseMapClientsResponseDefaultTypeInternal _increaseMapClientsResponse_default_instance_;
class requestMapProcessingRequest;
struct requestMapProcessingRequestDefaultTypeInternal;
extern requestMapProcessingRequestDefaultTypeInternal _requestMapProcessingRequest_default_instance_;
class requestMapProcessingResponse;
struct requestMapProcessingResponseDefaultTypeInternal;
extern requestMapProcessingResponseDefaultTypeInternal _requestMapProcessingResponse_default_instance_;
class setMapRequestRequest;
struct setMapRequestRequestDefaultTypeInternal;
extern setMapRequestRequestDefaultTypeInternal _setMapRequestRequest_default_instance_;
class setMapRequestResponse;
struct setMapRequestResponseDefaultTypeInternal;
extern setMapRequestResponseDefaultTypeInternal _setMapRequestResponse_default_instance_;
}  // namespace grpcIMapsManager
PROTOBUF_NAMESPACE_OPEN
template<> ::grpcIMapsManager::createMapRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::createMapRequest>(Arena*);
template<> ::grpcIMapsManager::createMapResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::createMapResponse>(Arena*);
template<> ::grpcIMapsManager::decreaseMapClientsRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::decreaseMapClientsRequest>(Arena*);
template<> ::grpcIMapsManager::decreaseMapClientsResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::decreaseMapClientsResponse>(Arena*);
template<> ::grpcIMapsManager::deleteMapRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::deleteMapRequest>(Arena*);
template<> ::grpcIMapsManager::deleteMapResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::deleteMapResponse>(Arena*);
template<> ::grpcIMapsManager::getAllMapsRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::getAllMapsRequest>(Arena*);
template<> ::grpcIMapsManager::getAllMapsResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::getAllMapsResponse>(Arena*);
template<> ::grpcIMapsManager::getMapInfoRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::getMapInfoRequest>(Arena*);
template<> ::grpcIMapsManager::getMapInfoResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::getMapInfoResponse>(Arena*);
template<> ::grpcIMapsManager::getMapProcessingDataRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::getMapProcessingDataRequest>(Arena*);
template<> ::grpcIMapsManager::getMapProcessingDataResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::getMapProcessingDataResponse>(Arena*);
template<> ::grpcIMapsManager::getMapProcessingStatusRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::getMapProcessingStatusRequest>(Arena*);
template<> ::grpcIMapsManager::getMapProcessingStatusResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::getMapProcessingStatusResponse>(Arena*);
template<> ::grpcIMapsManager::getMapRequestRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::getMapRequestRequest>(Arena*);
template<> ::grpcIMapsManager::getMapRequestResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::getMapRequestResponse>(Arena*);
template<> ::grpcIMapsManager::getPointCloudRequestRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::getPointCloudRequestRequest>(Arena*);
template<> ::grpcIMapsManager::getPointCloudRequestResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::getPointCloudRequestResponse>(Arena*);
template<> ::grpcIMapsManager::increaseMapClientsRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::increaseMapClientsRequest>(Arena*);
template<> ::grpcIMapsManager::increaseMapClientsResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::increaseMapClientsResponse>(Arena*);
template<> ::grpcIMapsManager::requestMapProcessingRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::requestMapProcessingRequest>(Arena*);
template<> ::grpcIMapsManager::requestMapProcessingResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::requestMapProcessingResponse>(Arena*);
template<> ::grpcIMapsManager::setMapRequestRequest* Arena::CreateMaybeMessage<::grpcIMapsManager::setMapRequestRequest>(Arena*);
template<> ::grpcIMapsManager::setMapRequestResponse* Arena::CreateMaybeMessage<::grpcIMapsManager::setMapRequestResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace grpcIMapsManager {

// ===================================================================

class createMapRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.createMapRequest) */ {
 public:
  inline createMapRequest() : createMapRequest(nullptr) {}
  ~createMapRequest() override;
  explicit PROTOBUF_CONSTEXPR createMapRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createMapRequest(const createMapRequest& from);
  createMapRequest(createMapRequest&& from) noexcept
    : createMapRequest() {
    *this = ::std::move(from);
  }

  inline createMapRequest& operator=(const createMapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline createMapRequest& operator=(createMapRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createMapRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const createMapRequest* internal_default_instance() {
    return reinterpret_cast<const createMapRequest*>(
               &_createMapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(createMapRequest& a, createMapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(createMapRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createMapRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createMapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createMapRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const createMapRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const createMapRequest& from) {
    createMapRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(createMapRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.createMapRequest";
  }
  protected:
  explicit createMapRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.createMapRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class createMapResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.createMapResponse) */ {
 public:
  inline createMapResponse() : createMapResponse(nullptr) {}
  ~createMapResponse() override;
  explicit PROTOBUF_CONSTEXPR createMapResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  createMapResponse(const createMapResponse& from);
  createMapResponse(createMapResponse&& from) noexcept
    : createMapResponse() {
    *this = ::std::move(from);
  }

  inline createMapResponse& operator=(const createMapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline createMapResponse& operator=(createMapResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const createMapResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const createMapResponse* internal_default_instance() {
    return reinterpret_cast<const createMapResponse*>(
               &_createMapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(createMapResponse& a, createMapResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(createMapResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(createMapResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  createMapResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<createMapResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const createMapResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const createMapResponse& from) {
    createMapResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(createMapResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.createMapResponse";
  }
  protected:
  explicit createMapResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.createMapResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class deleteMapRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.deleteMapRequest) */ {
 public:
  inline deleteMapRequest() : deleteMapRequest(nullptr) {}
  ~deleteMapRequest() override;
  explicit PROTOBUF_CONSTEXPR deleteMapRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  deleteMapRequest(const deleteMapRequest& from);
  deleteMapRequest(deleteMapRequest&& from) noexcept
    : deleteMapRequest() {
    *this = ::std::move(from);
  }

  inline deleteMapRequest& operator=(const deleteMapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline deleteMapRequest& operator=(deleteMapRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const deleteMapRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const deleteMapRequest* internal_default_instance() {
    return reinterpret_cast<const deleteMapRequest*>(
               &_deleteMapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(deleteMapRequest& a, deleteMapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(deleteMapRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deleteMapRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  deleteMapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<deleteMapRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const deleteMapRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const deleteMapRequest& from) {
    deleteMapRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deleteMapRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.deleteMapRequest";
  }
  protected:
  explicit deleteMapRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.deleteMapRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class deleteMapResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.deleteMapResponse) */ {
 public:
  inline deleteMapResponse() : deleteMapResponse(nullptr) {}
  ~deleteMapResponse() override;
  explicit PROTOBUF_CONSTEXPR deleteMapResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  deleteMapResponse(const deleteMapResponse& from);
  deleteMapResponse(deleteMapResponse&& from) noexcept
    : deleteMapResponse() {
    *this = ::std::move(from);
  }

  inline deleteMapResponse& operator=(const deleteMapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline deleteMapResponse& operator=(deleteMapResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const deleteMapResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const deleteMapResponse* internal_default_instance() {
    return reinterpret_cast<const deleteMapResponse*>(
               &_deleteMapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(deleteMapResponse& a, deleteMapResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(deleteMapResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(deleteMapResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  deleteMapResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<deleteMapResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const deleteMapResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const deleteMapResponse& from) {
    deleteMapResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(deleteMapResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.deleteMapResponse";
  }
  protected:
  explicit deleteMapResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.deleteMapResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getAllMapsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getAllMapsRequest) */ {
 public:
  inline getAllMapsRequest() : getAllMapsRequest(nullptr) {}
  ~getAllMapsRequest() override;
  explicit PROTOBUF_CONSTEXPR getAllMapsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getAllMapsRequest(const getAllMapsRequest& from);
  getAllMapsRequest(getAllMapsRequest&& from) noexcept
    : getAllMapsRequest() {
    *this = ::std::move(from);
  }

  inline getAllMapsRequest& operator=(const getAllMapsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline getAllMapsRequest& operator=(getAllMapsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getAllMapsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const getAllMapsRequest* internal_default_instance() {
    return reinterpret_cast<const getAllMapsRequest*>(
               &_getAllMapsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(getAllMapsRequest& a, getAllMapsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(getAllMapsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getAllMapsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getAllMapsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getAllMapsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getAllMapsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getAllMapsRequest& from) {
    getAllMapsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getAllMapsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getAllMapsRequest";
  }
  protected:
  explicit getAllMapsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDListFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // bytes mapUUIDList = 2;
  void clear_mapuuidlist();
  const std::string& mapuuidlist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuidlist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuidlist();
  PROTOBUF_NODISCARD std::string* release_mapuuidlist();
  void set_allocated_mapuuidlist(std::string* mapuuidlist);
  private:
  const std::string& _internal_mapuuidlist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuidlist(const std::string& value);
  std::string* _internal_mutable_mapuuidlist();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getAllMapsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuidlist_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getAllMapsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getAllMapsResponse) */ {
 public:
  inline getAllMapsResponse() : getAllMapsResponse(nullptr) {}
  ~getAllMapsResponse() override;
  explicit PROTOBUF_CONSTEXPR getAllMapsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getAllMapsResponse(const getAllMapsResponse& from);
  getAllMapsResponse(getAllMapsResponse&& from) noexcept
    : getAllMapsResponse() {
    *this = ::std::move(from);
  }

  inline getAllMapsResponse& operator=(const getAllMapsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline getAllMapsResponse& operator=(getAllMapsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getAllMapsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const getAllMapsResponse* internal_default_instance() {
    return reinterpret_cast<const getAllMapsResponse*>(
               &_getAllMapsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(getAllMapsResponse& a, getAllMapsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(getAllMapsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getAllMapsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getAllMapsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getAllMapsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getAllMapsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getAllMapsResponse& from) {
    getAllMapsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getAllMapsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getAllMapsResponse";
  }
  protected:
  explicit getAllMapsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDListFieldNumber = 1,
    kXpcfGrpcReturnValueFieldNumber = 2,
  };
  // bytes mapUUIDList = 1;
  void clear_mapuuidlist();
  const std::string& mapuuidlist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuidlist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuidlist();
  PROTOBUF_NODISCARD std::string* release_mapuuidlist();
  void set_allocated_mapuuidlist(std::string* mapuuidlist);
  private:
  const std::string& _internal_mapuuidlist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuidlist(const std::string& value);
  std::string* _internal_mutable_mapuuidlist();
  public:

  // sint32 xpcfGrpcReturnValue = 2;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getAllMapsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuidlist_;
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class increaseMapClientsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.increaseMapClientsRequest) */ {
 public:
  inline increaseMapClientsRequest() : increaseMapClientsRequest(nullptr) {}
  ~increaseMapClientsRequest() override;
  explicit PROTOBUF_CONSTEXPR increaseMapClientsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  increaseMapClientsRequest(const increaseMapClientsRequest& from);
  increaseMapClientsRequest(increaseMapClientsRequest&& from) noexcept
    : increaseMapClientsRequest() {
    *this = ::std::move(from);
  }

  inline increaseMapClientsRequest& operator=(const increaseMapClientsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline increaseMapClientsRequest& operator=(increaseMapClientsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const increaseMapClientsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const increaseMapClientsRequest* internal_default_instance() {
    return reinterpret_cast<const increaseMapClientsRequest*>(
               &_increaseMapClientsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(increaseMapClientsRequest& a, increaseMapClientsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(increaseMapClientsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(increaseMapClientsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  increaseMapClientsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<increaseMapClientsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const increaseMapClientsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const increaseMapClientsRequest& from) {
    increaseMapClientsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(increaseMapClientsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.increaseMapClientsRequest";
  }
  protected:
  explicit increaseMapClientsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kServiceURLFieldNumber = 3,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // string serviceURL = 3;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.increaseMapClientsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class increaseMapClientsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.increaseMapClientsResponse) */ {
 public:
  inline increaseMapClientsResponse() : increaseMapClientsResponse(nullptr) {}
  ~increaseMapClientsResponse() override;
  explicit PROTOBUF_CONSTEXPR increaseMapClientsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  increaseMapClientsResponse(const increaseMapClientsResponse& from);
  increaseMapClientsResponse(increaseMapClientsResponse&& from) noexcept
    : increaseMapClientsResponse() {
    *this = ::std::move(from);
  }

  inline increaseMapClientsResponse& operator=(const increaseMapClientsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline increaseMapClientsResponse& operator=(increaseMapClientsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const increaseMapClientsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const increaseMapClientsResponse* internal_default_instance() {
    return reinterpret_cast<const increaseMapClientsResponse*>(
               &_increaseMapClientsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(increaseMapClientsResponse& a, increaseMapClientsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(increaseMapClientsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(increaseMapClientsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  increaseMapClientsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<increaseMapClientsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const increaseMapClientsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const increaseMapClientsResponse& from) {
    increaseMapClientsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(increaseMapClientsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.increaseMapClientsResponse";
  }
  protected:
  explicit increaseMapClientsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceURLFieldNumber = 1,
    kXpcfGrpcReturnValueFieldNumber = 2,
  };
  // string serviceURL = 1;
  void clear_serviceurl();
  const std::string& serviceurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serviceurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serviceurl();
  PROTOBUF_NODISCARD std::string* release_serviceurl();
  void set_allocated_serviceurl(std::string* serviceurl);
  private:
  const std::string& _internal_serviceurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serviceurl(const std::string& value);
  std::string* _internal_mutable_serviceurl();
  public:

  // sint32 xpcfGrpcReturnValue = 2;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.increaseMapClientsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serviceurl_;
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class decreaseMapClientsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.decreaseMapClientsRequest) */ {
 public:
  inline decreaseMapClientsRequest() : decreaseMapClientsRequest(nullptr) {}
  ~decreaseMapClientsRequest() override;
  explicit PROTOBUF_CONSTEXPR decreaseMapClientsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  decreaseMapClientsRequest(const decreaseMapClientsRequest& from);
  decreaseMapClientsRequest(decreaseMapClientsRequest&& from) noexcept
    : decreaseMapClientsRequest() {
    *this = ::std::move(from);
  }

  inline decreaseMapClientsRequest& operator=(const decreaseMapClientsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline decreaseMapClientsRequest& operator=(decreaseMapClientsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const decreaseMapClientsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const decreaseMapClientsRequest* internal_default_instance() {
    return reinterpret_cast<const decreaseMapClientsRequest*>(
               &_decreaseMapClientsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(decreaseMapClientsRequest& a, decreaseMapClientsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(decreaseMapClientsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(decreaseMapClientsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  decreaseMapClientsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<decreaseMapClientsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const decreaseMapClientsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const decreaseMapClientsRequest& from) {
    decreaseMapClientsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(decreaseMapClientsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.decreaseMapClientsRequest";
  }
  protected:
  explicit decreaseMapClientsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.decreaseMapClientsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class decreaseMapClientsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.decreaseMapClientsResponse) */ {
 public:
  inline decreaseMapClientsResponse() : decreaseMapClientsResponse(nullptr) {}
  ~decreaseMapClientsResponse() override;
  explicit PROTOBUF_CONSTEXPR decreaseMapClientsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  decreaseMapClientsResponse(const decreaseMapClientsResponse& from);
  decreaseMapClientsResponse(decreaseMapClientsResponse&& from) noexcept
    : decreaseMapClientsResponse() {
    *this = ::std::move(from);
  }

  inline decreaseMapClientsResponse& operator=(const decreaseMapClientsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline decreaseMapClientsResponse& operator=(decreaseMapClientsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const decreaseMapClientsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const decreaseMapClientsResponse* internal_default_instance() {
    return reinterpret_cast<const decreaseMapClientsResponse*>(
               &_decreaseMapClientsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(decreaseMapClientsResponse& a, decreaseMapClientsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(decreaseMapClientsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(decreaseMapClientsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  decreaseMapClientsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<decreaseMapClientsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const decreaseMapClientsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const decreaseMapClientsResponse& from) {
    decreaseMapClientsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(decreaseMapClientsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.decreaseMapClientsResponse";
  }
  protected:
  explicit decreaseMapClientsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.decreaseMapClientsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getMapRequestRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getMapRequestRequest) */ {
 public:
  inline getMapRequestRequest() : getMapRequestRequest(nullptr) {}
  ~getMapRequestRequest() override;
  explicit PROTOBUF_CONSTEXPR getMapRequestRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getMapRequestRequest(const getMapRequestRequest& from);
  getMapRequestRequest(getMapRequestRequest&& from) noexcept
    : getMapRequestRequest() {
    *this = ::std::move(from);
  }

  inline getMapRequestRequest& operator=(const getMapRequestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline getMapRequestRequest& operator=(getMapRequestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getMapRequestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const getMapRequestRequest* internal_default_instance() {
    return reinterpret_cast<const getMapRequestRequest*>(
               &_getMapRequestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(getMapRequestRequest& a, getMapRequestRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(getMapRequestRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getMapRequestRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getMapRequestRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getMapRequestRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getMapRequestRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getMapRequestRequest& from) {
    getMapRequestRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getMapRequestRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getMapRequestRequest";
  }
  protected:
  explicit getMapRequestRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kMapFieldNumber = 4,
    kGrpcServerCompressionFormatFieldNumber = 1,
    kWithKeyframeImagesFieldNumber = 3,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // bytes map = 4;
  void clear_map();
  const std::string& map() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map();
  PROTOBUF_NODISCARD std::string* release_map();
  void set_allocated_map(std::string* map);
  private:
  const std::string& _internal_map() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map(const std::string& value);
  std::string* _internal_mutable_map();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // bool withKeyframeImages = 3;
  void clear_withkeyframeimages();
  bool withkeyframeimages() const;
  void set_withkeyframeimages(bool value);
  private:
  bool _internal_withkeyframeimages() const;
  void _internal_set_withkeyframeimages(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getMapRequestRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_;
    int32_t grpcservercompressionformat_;
    bool withkeyframeimages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getMapRequestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getMapRequestResponse) */ {
 public:
  inline getMapRequestResponse() : getMapRequestResponse(nullptr) {}
  ~getMapRequestResponse() override;
  explicit PROTOBUF_CONSTEXPR getMapRequestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getMapRequestResponse(const getMapRequestResponse& from);
  getMapRequestResponse(getMapRequestResponse&& from) noexcept
    : getMapRequestResponse() {
    *this = ::std::move(from);
  }

  inline getMapRequestResponse& operator=(const getMapRequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline getMapRequestResponse& operator=(getMapRequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getMapRequestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const getMapRequestResponse* internal_default_instance() {
    return reinterpret_cast<const getMapRequestResponse*>(
               &_getMapRequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(getMapRequestResponse& a, getMapRequestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(getMapRequestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getMapRequestResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getMapRequestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getMapRequestResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getMapRequestResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getMapRequestResponse& from) {
    getMapRequestResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getMapRequestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getMapRequestResponse";
  }
  protected:
  explicit getMapRequestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapFieldNumber = 1,
    kXpcfGrpcReturnValueFieldNumber = 2,
  };
  // bytes map = 1;
  void clear_map();
  const std::string& map() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map();
  PROTOBUF_NODISCARD std::string* release_map();
  void set_allocated_map(std::string* map);
  private:
  const std::string& _internal_map() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map(const std::string& value);
  std::string* _internal_mutable_map();
  public:

  // sint32 xpcfGrpcReturnValue = 2;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getMapRequestResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_;
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class setMapRequestRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.setMapRequestRequest) */ {
 public:
  inline setMapRequestRequest() : setMapRequestRequest(nullptr) {}
  ~setMapRequestRequest() override;
  explicit PROTOBUF_CONSTEXPR setMapRequestRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  setMapRequestRequest(const setMapRequestRequest& from);
  setMapRequestRequest(setMapRequestRequest&& from) noexcept
    : setMapRequestRequest() {
    *this = ::std::move(from);
  }

  inline setMapRequestRequest& operator=(const setMapRequestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline setMapRequestRequest& operator=(setMapRequestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const setMapRequestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const setMapRequestRequest* internal_default_instance() {
    return reinterpret_cast<const setMapRequestRequest*>(
               &_setMapRequestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(setMapRequestRequest& a, setMapRequestRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(setMapRequestRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(setMapRequestRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  setMapRequestRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<setMapRequestRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const setMapRequestRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const setMapRequestRequest& from) {
    setMapRequestRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(setMapRequestRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.setMapRequestRequest";
  }
  protected:
  explicit setMapRequestRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kMapDatastructureFieldNumber = 3,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // bytes mapDatastructure = 3;
  void clear_mapdatastructure();
  const std::string& mapdatastructure() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapdatastructure(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapdatastructure();
  PROTOBUF_NODISCARD std::string* release_mapdatastructure();
  void set_allocated_mapdatastructure(std::string* mapdatastructure);
  private:
  const std::string& _internal_mapdatastructure() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapdatastructure(const std::string& value);
  std::string* _internal_mutable_mapdatastructure();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.setMapRequestRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapdatastructure_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class setMapRequestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.setMapRequestResponse) */ {
 public:
  inline setMapRequestResponse() : setMapRequestResponse(nullptr) {}
  ~setMapRequestResponse() override;
  explicit PROTOBUF_CONSTEXPR setMapRequestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  setMapRequestResponse(const setMapRequestResponse& from);
  setMapRequestResponse(setMapRequestResponse&& from) noexcept
    : setMapRequestResponse() {
    *this = ::std::move(from);
  }

  inline setMapRequestResponse& operator=(const setMapRequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline setMapRequestResponse& operator=(setMapRequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const setMapRequestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const setMapRequestResponse* internal_default_instance() {
    return reinterpret_cast<const setMapRequestResponse*>(
               &_setMapRequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(setMapRequestResponse& a, setMapRequestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(setMapRequestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(setMapRequestResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  setMapRequestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<setMapRequestResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const setMapRequestResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const setMapRequestResponse& from) {
    setMapRequestResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(setMapRequestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.setMapRequestResponse";
  }
  protected:
  explicit setMapRequestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.setMapRequestResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getPointCloudRequestRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getPointCloudRequestRequest) */ {
 public:
  inline getPointCloudRequestRequest() : getPointCloudRequestRequest(nullptr) {}
  ~getPointCloudRequestRequest() override;
  explicit PROTOBUF_CONSTEXPR getPointCloudRequestRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getPointCloudRequestRequest(const getPointCloudRequestRequest& from);
  getPointCloudRequestRequest(getPointCloudRequestRequest&& from) noexcept
    : getPointCloudRequestRequest() {
    *this = ::std::move(from);
  }

  inline getPointCloudRequestRequest& operator=(const getPointCloudRequestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline getPointCloudRequestRequest& operator=(getPointCloudRequestRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getPointCloudRequestRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const getPointCloudRequestRequest* internal_default_instance() {
    return reinterpret_cast<const getPointCloudRequestRequest*>(
               &_getPointCloudRequestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(getPointCloudRequestRequest& a, getPointCloudRequestRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(getPointCloudRequestRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getPointCloudRequestRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getPointCloudRequestRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getPointCloudRequestRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getPointCloudRequestRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getPointCloudRequestRequest& from) {
    getPointCloudRequestRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getPointCloudRequestRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getPointCloudRequestRequest";
  }
  protected:
  explicit getPointCloudRequestRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kPointCloudFieldNumber = 3,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // bytes pointCloud = 3;
  void clear_pointcloud();
  const std::string& pointcloud() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pointcloud(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pointcloud();
  PROTOBUF_NODISCARD std::string* release_pointcloud();
  void set_allocated_pointcloud(std::string* pointcloud);
  private:
  const std::string& _internal_pointcloud() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pointcloud(const std::string& value);
  std::string* _internal_mutable_pointcloud();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getPointCloudRequestRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pointcloud_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getPointCloudRequestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getPointCloudRequestResponse) */ {
 public:
  inline getPointCloudRequestResponse() : getPointCloudRequestResponse(nullptr) {}
  ~getPointCloudRequestResponse() override;
  explicit PROTOBUF_CONSTEXPR getPointCloudRequestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getPointCloudRequestResponse(const getPointCloudRequestResponse& from);
  getPointCloudRequestResponse(getPointCloudRequestResponse&& from) noexcept
    : getPointCloudRequestResponse() {
    *this = ::std::move(from);
  }

  inline getPointCloudRequestResponse& operator=(const getPointCloudRequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline getPointCloudRequestResponse& operator=(getPointCloudRequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getPointCloudRequestResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const getPointCloudRequestResponse* internal_default_instance() {
    return reinterpret_cast<const getPointCloudRequestResponse*>(
               &_getPointCloudRequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(getPointCloudRequestResponse& a, getPointCloudRequestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(getPointCloudRequestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getPointCloudRequestResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getPointCloudRequestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getPointCloudRequestResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getPointCloudRequestResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getPointCloudRequestResponse& from) {
    getPointCloudRequestResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getPointCloudRequestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getPointCloudRequestResponse";
  }
  protected:
  explicit getPointCloudRequestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointCloudFieldNumber = 1,
    kXpcfGrpcReturnValueFieldNumber = 2,
  };
  // bytes pointCloud = 1;
  void clear_pointcloud();
  const std::string& pointcloud() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pointcloud(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pointcloud();
  PROTOBUF_NODISCARD std::string* release_pointcloud();
  void set_allocated_pointcloud(std::string* pointcloud);
  private:
  const std::string& _internal_pointcloud() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pointcloud(const std::string& value);
  std::string* _internal_mutable_pointcloud();
  public:

  // sint32 xpcfGrpcReturnValue = 2;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getPointCloudRequestResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pointcloud_;
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getMapInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getMapInfoRequest) */ {
 public:
  inline getMapInfoRequest() : getMapInfoRequest(nullptr) {}
  ~getMapInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR getMapInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getMapInfoRequest(const getMapInfoRequest& from);
  getMapInfoRequest(getMapInfoRequest&& from) noexcept
    : getMapInfoRequest() {
    *this = ::std::move(from);
  }

  inline getMapInfoRequest& operator=(const getMapInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline getMapInfoRequest& operator=(getMapInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getMapInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const getMapInfoRequest* internal_default_instance() {
    return reinterpret_cast<const getMapInfoRequest*>(
               &_getMapInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(getMapInfoRequest& a, getMapInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(getMapInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getMapInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getMapInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getMapInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getMapInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getMapInfoRequest& from) {
    getMapInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getMapInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getMapInfoRequest";
  }
  protected:
  explicit getMapInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
    kDescriptorTypeFieldNumber = 3,
    kMapSupportedTypesFieldNumber = 4,
    kDataSizeFieldNumber = 5,
    kAreImageSavedFieldNumber = 6,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // sint32 descriptorType = 3;
  void clear_descriptortype();
  int32_t descriptortype() const;
  void set_descriptortype(int32_t value);
  private:
  int32_t _internal_descriptortype() const;
  void _internal_set_descriptortype(int32_t value);
  public:

  // uint32 mapSupportedTypes = 4;
  void clear_mapsupportedtypes();
  uint32_t mapsupportedtypes() const;
  void set_mapsupportedtypes(uint32_t value);
  private:
  uint32_t _internal_mapsupportedtypes() const;
  void _internal_set_mapsupportedtypes(uint32_t value);
  public:

  // uint32 dataSize = 5;
  void clear_datasize();
  uint32_t datasize() const;
  void set_datasize(uint32_t value);
  private:
  uint32_t _internal_datasize() const;
  void _internal_set_datasize(uint32_t value);
  public:

  // bool areImageSaved = 6;
  void clear_areimagesaved();
  bool areimagesaved() const;
  void set_areimagesaved(bool value);
  private:
  bool _internal_areimagesaved() const;
  void _internal_set_areimagesaved(bool value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getMapInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    int32_t grpcservercompressionformat_;
    int32_t descriptortype_;
    uint32_t mapsupportedtypes_;
    uint32_t datasize_;
    bool areimagesaved_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getMapInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getMapInfoResponse) */ {
 public:
  inline getMapInfoResponse() : getMapInfoResponse(nullptr) {}
  ~getMapInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR getMapInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getMapInfoResponse(const getMapInfoResponse& from);
  getMapInfoResponse(getMapInfoResponse&& from) noexcept
    : getMapInfoResponse() {
    *this = ::std::move(from);
  }

  inline getMapInfoResponse& operator=(const getMapInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline getMapInfoResponse& operator=(getMapInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getMapInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const getMapInfoResponse* internal_default_instance() {
    return reinterpret_cast<const getMapInfoResponse*>(
               &_getMapInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(getMapInfoResponse& a, getMapInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(getMapInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getMapInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getMapInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getMapInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getMapInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getMapInfoResponse& from) {
    getMapInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getMapInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getMapInfoResponse";
  }
  protected:
  explicit getMapInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptorTypeFieldNumber = 1,
    kMapSupportedTypesFieldNumber = 2,
    kDataSizeFieldNumber = 3,
    kAreImageSavedFieldNumber = 4,
    kXpcfGrpcReturnValueFieldNumber = 5,
  };
  // sint32 descriptorType = 1;
  void clear_descriptortype();
  int32_t descriptortype() const;
  void set_descriptortype(int32_t value);
  private:
  int32_t _internal_descriptortype() const;
  void _internal_set_descriptortype(int32_t value);
  public:

  // uint32 mapSupportedTypes = 2;
  void clear_mapsupportedtypes();
  uint32_t mapsupportedtypes() const;
  void set_mapsupportedtypes(uint32_t value);
  private:
  uint32_t _internal_mapsupportedtypes() const;
  void _internal_set_mapsupportedtypes(uint32_t value);
  public:

  // uint32 dataSize = 3;
  void clear_datasize();
  uint32_t datasize() const;
  void set_datasize(uint32_t value);
  private:
  uint32_t _internal_datasize() const;
  void _internal_set_datasize(uint32_t value);
  public:

  // bool areImageSaved = 4;
  void clear_areimagesaved();
  bool areimagesaved() const;
  void set_areimagesaved(bool value);
  private:
  bool _internal_areimagesaved() const;
  void _internal_set_areimagesaved(bool value);
  public:

  // sint32 xpcfGrpcReturnValue = 5;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getMapInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t descriptortype_;
    uint32_t mapsupportedtypes_;
    uint32_t datasize_;
    bool areimagesaved_;
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class requestMapProcessingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.requestMapProcessingRequest) */ {
 public:
  inline requestMapProcessingRequest() : requestMapProcessingRequest(nullptr) {}
  ~requestMapProcessingRequest() override;
  explicit PROTOBUF_CONSTEXPR requestMapProcessingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  requestMapProcessingRequest(const requestMapProcessingRequest& from);
  requestMapProcessingRequest(requestMapProcessingRequest&& from) noexcept
    : requestMapProcessingRequest() {
    *this = ::std::move(from);
  }

  inline requestMapProcessingRequest& operator=(const requestMapProcessingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline requestMapProcessingRequest& operator=(requestMapProcessingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const requestMapProcessingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const requestMapProcessingRequest* internal_default_instance() {
    return reinterpret_cast<const requestMapProcessingRequest*>(
               &_requestMapProcessingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(requestMapProcessingRequest& a, requestMapProcessingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(requestMapProcessingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(requestMapProcessingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  requestMapProcessingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<requestMapProcessingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const requestMapProcessingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const requestMapProcessingRequest& from) {
    requestMapProcessingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(requestMapProcessingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.requestMapProcessingRequest";
  }
  protected:
  explicit requestMapProcessingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapUUIDFieldNumber = 2,
    kResultMapUUIDFieldNumber = 3,
    kGrpcServerCompressionFormatFieldNumber = 1,
    kProcessingTypeFieldNumber = 4,
  };
  // string mapUUID = 2;
  void clear_mapuuid();
  const std::string& mapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapuuid();
  PROTOBUF_NODISCARD std::string* release_mapuuid();
  void set_allocated_mapuuid(std::string* mapuuid);
  private:
  const std::string& _internal_mapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapuuid(const std::string& value);
  std::string* _internal_mutable_mapuuid();
  public:

  // string resultMapUUID = 3;
  void clear_resultmapuuid();
  const std::string& resultmapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resultmapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resultmapuuid();
  PROTOBUF_NODISCARD std::string* release_resultmapuuid();
  void set_allocated_resultmapuuid(std::string* resultmapuuid);
  private:
  const std::string& _internal_resultmapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resultmapuuid(const std::string& value);
  std::string* _internal_mutable_resultmapuuid();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // sint32 processingType = 4;
  void clear_processingtype();
  int32_t processingtype() const;
  void set_processingtype(int32_t value);
  private:
  int32_t _internal_processingtype() const;
  void _internal_set_processingtype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.requestMapProcessingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapuuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resultmapuuid_;
    int32_t grpcservercompressionformat_;
    int32_t processingtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class requestMapProcessingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.requestMapProcessingResponse) */ {
 public:
  inline requestMapProcessingResponse() : requestMapProcessingResponse(nullptr) {}
  ~requestMapProcessingResponse() override;
  explicit PROTOBUF_CONSTEXPR requestMapProcessingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  requestMapProcessingResponse(const requestMapProcessingResponse& from);
  requestMapProcessingResponse(requestMapProcessingResponse&& from) noexcept
    : requestMapProcessingResponse() {
    *this = ::std::move(from);
  }

  inline requestMapProcessingResponse& operator=(const requestMapProcessingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline requestMapProcessingResponse& operator=(requestMapProcessingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const requestMapProcessingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const requestMapProcessingResponse* internal_default_instance() {
    return reinterpret_cast<const requestMapProcessingResponse*>(
               &_requestMapProcessingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(requestMapProcessingResponse& a, requestMapProcessingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(requestMapProcessingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(requestMapProcessingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  requestMapProcessingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<requestMapProcessingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const requestMapProcessingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const requestMapProcessingResponse& from) {
    requestMapProcessingResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(requestMapProcessingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.requestMapProcessingResponse";
  }
  protected:
  explicit requestMapProcessingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXpcfGrpcReturnValueFieldNumber = 1,
  };
  // sint32 xpcfGrpcReturnValue = 1;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.requestMapProcessingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getMapProcessingStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getMapProcessingStatusRequest) */ {
 public:
  inline getMapProcessingStatusRequest() : getMapProcessingStatusRequest(nullptr) {}
  ~getMapProcessingStatusRequest() override;
  explicit PROTOBUF_CONSTEXPR getMapProcessingStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getMapProcessingStatusRequest(const getMapProcessingStatusRequest& from);
  getMapProcessingStatusRequest(getMapProcessingStatusRequest&& from) noexcept
    : getMapProcessingStatusRequest() {
    *this = ::std::move(from);
  }

  inline getMapProcessingStatusRequest& operator=(const getMapProcessingStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline getMapProcessingStatusRequest& operator=(getMapProcessingStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getMapProcessingStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const getMapProcessingStatusRequest* internal_default_instance() {
    return reinterpret_cast<const getMapProcessingStatusRequest*>(
               &_getMapProcessingStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(getMapProcessingStatusRequest& a, getMapProcessingStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(getMapProcessingStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getMapProcessingStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getMapProcessingStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getMapProcessingStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getMapProcessingStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getMapProcessingStatusRequest& from) {
    getMapProcessingStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getMapProcessingStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getMapProcessingStatusRequest";
  }
  protected:
  explicit getMapProcessingStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultMapUUIDFieldNumber = 2,
    kGrpcServerCompressionFormatFieldNumber = 1,
    kStatusFieldNumber = 3,
    kProgressFieldNumber = 4,
  };
  // string resultMapUUID = 2;
  void clear_resultmapuuid();
  const std::string& resultmapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resultmapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resultmapuuid();
  PROTOBUF_NODISCARD std::string* release_resultmapuuid();
  void set_allocated_resultmapuuid(std::string* resultmapuuid);
  private:
  const std::string& _internal_resultmapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resultmapuuid(const std::string& value);
  std::string* _internal_mutable_resultmapuuid();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // sint32 status = 3;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // float progress = 4;
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getMapProcessingStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resultmapuuid_;
    int32_t grpcservercompressionformat_;
    int32_t status_;
    float progress_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getMapProcessingStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getMapProcessingStatusResponse) */ {
 public:
  inline getMapProcessingStatusResponse() : getMapProcessingStatusResponse(nullptr) {}
  ~getMapProcessingStatusResponse() override;
  explicit PROTOBUF_CONSTEXPR getMapProcessingStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getMapProcessingStatusResponse(const getMapProcessingStatusResponse& from);
  getMapProcessingStatusResponse(getMapProcessingStatusResponse&& from) noexcept
    : getMapProcessingStatusResponse() {
    *this = ::std::move(from);
  }

  inline getMapProcessingStatusResponse& operator=(const getMapProcessingStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline getMapProcessingStatusResponse& operator=(getMapProcessingStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getMapProcessingStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const getMapProcessingStatusResponse* internal_default_instance() {
    return reinterpret_cast<const getMapProcessingStatusResponse*>(
               &_getMapProcessingStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(getMapProcessingStatusResponse& a, getMapProcessingStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(getMapProcessingStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getMapProcessingStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getMapProcessingStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getMapProcessingStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getMapProcessingStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getMapProcessingStatusResponse& from) {
    getMapProcessingStatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getMapProcessingStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getMapProcessingStatusResponse";
  }
  protected:
  explicit getMapProcessingStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kProgressFieldNumber = 2,
    kXpcfGrpcReturnValueFieldNumber = 3,
  };
  // sint32 status = 1;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // float progress = 2;
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // sint32 xpcfGrpcReturnValue = 3;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getMapProcessingStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t status_;
    float progress_;
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getMapProcessingDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getMapProcessingDataRequest) */ {
 public:
  inline getMapProcessingDataRequest() : getMapProcessingDataRequest(nullptr) {}
  ~getMapProcessingDataRequest() override;
  explicit PROTOBUF_CONSTEXPR getMapProcessingDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getMapProcessingDataRequest(const getMapProcessingDataRequest& from);
  getMapProcessingDataRequest(getMapProcessingDataRequest&& from) noexcept
    : getMapProcessingDataRequest() {
    *this = ::std::move(from);
  }

  inline getMapProcessingDataRequest& operator=(const getMapProcessingDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline getMapProcessingDataRequest& operator=(getMapProcessingDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getMapProcessingDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const getMapProcessingDataRequest* internal_default_instance() {
    return reinterpret_cast<const getMapProcessingDataRequest*>(
               &_getMapProcessingDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(getMapProcessingDataRequest& a, getMapProcessingDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(getMapProcessingDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getMapProcessingDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getMapProcessingDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getMapProcessingDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getMapProcessingDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getMapProcessingDataRequest& from) {
    getMapProcessingDataRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getMapProcessingDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getMapProcessingDataRequest";
  }
  protected:
  explicit getMapProcessingDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultMapUUIDFieldNumber = 2,
    kPointCloudFieldNumber = 3,
    kKeyframePosesFieldNumber = 4,
    kGrpcServerCompressionFormatFieldNumber = 1,
  };
  // string resultMapUUID = 2;
  void clear_resultmapuuid();
  const std::string& resultmapuuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resultmapuuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resultmapuuid();
  PROTOBUF_NODISCARD std::string* release_resultmapuuid();
  void set_allocated_resultmapuuid(std::string* resultmapuuid);
  private:
  const std::string& _internal_resultmapuuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resultmapuuid(const std::string& value);
  std::string* _internal_mutable_resultmapuuid();
  public:

  // bytes pointCloud = 3;
  void clear_pointcloud();
  const std::string& pointcloud() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pointcloud(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pointcloud();
  PROTOBUF_NODISCARD std::string* release_pointcloud();
  void set_allocated_pointcloud(std::string* pointcloud);
  private:
  const std::string& _internal_pointcloud() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pointcloud(const std::string& value);
  std::string* _internal_mutable_pointcloud();
  public:

  // bytes keyframePoses = 4;
  void clear_keyframeposes();
  const std::string& keyframeposes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyframeposes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyframeposes();
  PROTOBUF_NODISCARD std::string* release_keyframeposes();
  void set_allocated_keyframeposes(std::string* keyframeposes);
  private:
  const std::string& _internal_keyframeposes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyframeposes(const std::string& value);
  std::string* _internal_mutable_keyframeposes();
  public:

  // int32 grpcServerCompressionFormat = 1;
  void clear_grpcservercompressionformat();
  int32_t grpcservercompressionformat() const;
  void set_grpcservercompressionformat(int32_t value);
  private:
  int32_t _internal_grpcservercompressionformat() const;
  void _internal_set_grpcservercompressionformat(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getMapProcessingDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resultmapuuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pointcloud_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyframeposes_;
    int32_t grpcservercompressionformat_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// -------------------------------------------------------------------

class getMapProcessingDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:grpcIMapsManager.getMapProcessingDataResponse) */ {
 public:
  inline getMapProcessingDataResponse() : getMapProcessingDataResponse(nullptr) {}
  ~getMapProcessingDataResponse() override;
  explicit PROTOBUF_CONSTEXPR getMapProcessingDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  getMapProcessingDataResponse(const getMapProcessingDataResponse& from);
  getMapProcessingDataResponse(getMapProcessingDataResponse&& from) noexcept
    : getMapProcessingDataResponse() {
    *this = ::std::move(from);
  }

  inline getMapProcessingDataResponse& operator=(const getMapProcessingDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline getMapProcessingDataResponse& operator=(getMapProcessingDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getMapProcessingDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const getMapProcessingDataResponse* internal_default_instance() {
    return reinterpret_cast<const getMapProcessingDataResponse*>(
               &_getMapProcessingDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(getMapProcessingDataResponse& a, getMapProcessingDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(getMapProcessingDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getMapProcessingDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getMapProcessingDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getMapProcessingDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const getMapProcessingDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const getMapProcessingDataResponse& from) {
    getMapProcessingDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getMapProcessingDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "grpcIMapsManager.getMapProcessingDataResponse";
  }
  protected:
  explicit getMapProcessingDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointCloudFieldNumber = 1,
    kKeyframePosesFieldNumber = 2,
    kXpcfGrpcReturnValueFieldNumber = 3,
  };
  // bytes pointCloud = 1;
  void clear_pointcloud();
  const std::string& pointcloud() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pointcloud(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pointcloud();
  PROTOBUF_NODISCARD std::string* release_pointcloud();
  void set_allocated_pointcloud(std::string* pointcloud);
  private:
  const std::string& _internal_pointcloud() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pointcloud(const std::string& value);
  std::string* _internal_mutable_pointcloud();
  public:

  // bytes keyframePoses = 2;
  void clear_keyframeposes();
  const std::string& keyframeposes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyframeposes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyframeposes();
  PROTOBUF_NODISCARD std::string* release_keyframeposes();
  void set_allocated_keyframeposes(std::string* keyframeposes);
  private:
  const std::string& _internal_keyframeposes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyframeposes(const std::string& value);
  std::string* _internal_mutable_keyframeposes();
  public:

  // sint32 xpcfGrpcReturnValue = 3;
  void clear_xpcfgrpcreturnvalue();
  int32_t xpcfgrpcreturnvalue() const;
  void set_xpcfgrpcreturnvalue(int32_t value);
  private:
  int32_t _internal_xpcfgrpcreturnvalue() const;
  void _internal_set_xpcfgrpcreturnvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:grpcIMapsManager.getMapProcessingDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pointcloud_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyframeposes_;
    int32_t xpcfgrpcreturnvalue_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_grpcIMapsManagerService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// createMapRequest

// int32 grpcServerCompressionFormat = 1;
inline void createMapRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t createMapRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t createMapRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.createMapRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void createMapRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void createMapRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.createMapRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void createMapRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& createMapRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.createMapRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void createMapRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.createMapRequest.mapUUID)
}
inline std::string* createMapRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.createMapRequest.mapUUID)
  return _s;
}
inline const std::string& createMapRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void createMapRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* createMapRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* createMapRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.createMapRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void createMapRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.createMapRequest.mapUUID)
}

// -------------------------------------------------------------------

// createMapResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void createMapResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t createMapResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t createMapResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.createMapResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void createMapResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void createMapResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.createMapResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// deleteMapRequest

// int32 grpcServerCompressionFormat = 1;
inline void deleteMapRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t deleteMapRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t deleteMapRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.deleteMapRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void deleteMapRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void deleteMapRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.deleteMapRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void deleteMapRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& deleteMapRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.deleteMapRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void deleteMapRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.deleteMapRequest.mapUUID)
}
inline std::string* deleteMapRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.deleteMapRequest.mapUUID)
  return _s;
}
inline const std::string& deleteMapRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void deleteMapRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* deleteMapRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* deleteMapRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.deleteMapRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void deleteMapRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.deleteMapRequest.mapUUID)
}

// -------------------------------------------------------------------

// deleteMapResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void deleteMapResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t deleteMapResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t deleteMapResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.deleteMapResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void deleteMapResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void deleteMapResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.deleteMapResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// getAllMapsRequest

// int32 grpcServerCompressionFormat = 1;
inline void getAllMapsRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t getAllMapsRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t getAllMapsRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getAllMapsRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void getAllMapsRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void getAllMapsRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getAllMapsRequest.grpcServerCompressionFormat)
}

// bytes mapUUIDList = 2;
inline void getAllMapsRequest::clear_mapuuidlist() {
  _impl_.mapuuidlist_.ClearToEmpty();
}
inline const std::string& getAllMapsRequest::mapuuidlist() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getAllMapsRequest.mapUUIDList)
  return _internal_mapuuidlist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getAllMapsRequest::set_mapuuidlist(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuidlist_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getAllMapsRequest.mapUUIDList)
}
inline std::string* getAllMapsRequest::mutable_mapuuidlist() {
  std::string* _s = _internal_mutable_mapuuidlist();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getAllMapsRequest.mapUUIDList)
  return _s;
}
inline const std::string& getAllMapsRequest::_internal_mapuuidlist() const {
  return _impl_.mapuuidlist_.Get();
}
inline void getAllMapsRequest::_internal_set_mapuuidlist(const std::string& value) {
  
  _impl_.mapuuidlist_.Set(value, GetArenaForAllocation());
}
inline std::string* getAllMapsRequest::_internal_mutable_mapuuidlist() {
  
  return _impl_.mapuuidlist_.Mutable(GetArenaForAllocation());
}
inline std::string* getAllMapsRequest::release_mapuuidlist() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getAllMapsRequest.mapUUIDList)
  return _impl_.mapuuidlist_.Release();
}
inline void getAllMapsRequest::set_allocated_mapuuidlist(std::string* mapuuidlist) {
  if (mapuuidlist != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuidlist_.SetAllocated(mapuuidlist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuidlist_.IsDefault()) {
    _impl_.mapuuidlist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getAllMapsRequest.mapUUIDList)
}

// -------------------------------------------------------------------

// getAllMapsResponse

// bytes mapUUIDList = 1;
inline void getAllMapsResponse::clear_mapuuidlist() {
  _impl_.mapuuidlist_.ClearToEmpty();
}
inline const std::string& getAllMapsResponse::mapuuidlist() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getAllMapsResponse.mapUUIDList)
  return _internal_mapuuidlist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getAllMapsResponse::set_mapuuidlist(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuidlist_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getAllMapsResponse.mapUUIDList)
}
inline std::string* getAllMapsResponse::mutable_mapuuidlist() {
  std::string* _s = _internal_mutable_mapuuidlist();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getAllMapsResponse.mapUUIDList)
  return _s;
}
inline const std::string& getAllMapsResponse::_internal_mapuuidlist() const {
  return _impl_.mapuuidlist_.Get();
}
inline void getAllMapsResponse::_internal_set_mapuuidlist(const std::string& value) {
  
  _impl_.mapuuidlist_.Set(value, GetArenaForAllocation());
}
inline std::string* getAllMapsResponse::_internal_mutable_mapuuidlist() {
  
  return _impl_.mapuuidlist_.Mutable(GetArenaForAllocation());
}
inline std::string* getAllMapsResponse::release_mapuuidlist() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getAllMapsResponse.mapUUIDList)
  return _impl_.mapuuidlist_.Release();
}
inline void getAllMapsResponse::set_allocated_mapuuidlist(std::string* mapuuidlist) {
  if (mapuuidlist != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuidlist_.SetAllocated(mapuuidlist, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuidlist_.IsDefault()) {
    _impl_.mapuuidlist_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getAllMapsResponse.mapUUIDList)
}

// sint32 xpcfGrpcReturnValue = 2;
inline void getAllMapsResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t getAllMapsResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t getAllMapsResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getAllMapsResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void getAllMapsResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void getAllMapsResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getAllMapsResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// increaseMapClientsRequest

// int32 grpcServerCompressionFormat = 1;
inline void increaseMapClientsRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t increaseMapClientsRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t increaseMapClientsRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.increaseMapClientsRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void increaseMapClientsRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void increaseMapClientsRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.increaseMapClientsRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void increaseMapClientsRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& increaseMapClientsRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.increaseMapClientsRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void increaseMapClientsRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.increaseMapClientsRequest.mapUUID)
}
inline std::string* increaseMapClientsRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.increaseMapClientsRequest.mapUUID)
  return _s;
}
inline const std::string& increaseMapClientsRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void increaseMapClientsRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* increaseMapClientsRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* increaseMapClientsRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.increaseMapClientsRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void increaseMapClientsRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.increaseMapClientsRequest.mapUUID)
}

// string serviceURL = 3;
inline void increaseMapClientsRequest::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& increaseMapClientsRequest::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.increaseMapClientsRequest.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void increaseMapClientsRequest::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.increaseMapClientsRequest.serviceURL)
}
inline std::string* increaseMapClientsRequest::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.increaseMapClientsRequest.serviceURL)
  return _s;
}
inline const std::string& increaseMapClientsRequest::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void increaseMapClientsRequest::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* increaseMapClientsRequest::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* increaseMapClientsRequest::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.increaseMapClientsRequest.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void increaseMapClientsRequest::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.increaseMapClientsRequest.serviceURL)
}

// -------------------------------------------------------------------

// increaseMapClientsResponse

// string serviceURL = 1;
inline void increaseMapClientsResponse::clear_serviceurl() {
  _impl_.serviceurl_.ClearToEmpty();
}
inline const std::string& increaseMapClientsResponse::serviceurl() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.increaseMapClientsResponse.serviceURL)
  return _internal_serviceurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void increaseMapClientsResponse::set_serviceurl(ArgT0&& arg0, ArgT... args) {
 
 _impl_.serviceurl_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.increaseMapClientsResponse.serviceURL)
}
inline std::string* increaseMapClientsResponse::mutable_serviceurl() {
  std::string* _s = _internal_mutable_serviceurl();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.increaseMapClientsResponse.serviceURL)
  return _s;
}
inline const std::string& increaseMapClientsResponse::_internal_serviceurl() const {
  return _impl_.serviceurl_.Get();
}
inline void increaseMapClientsResponse::_internal_set_serviceurl(const std::string& value) {
  
  _impl_.serviceurl_.Set(value, GetArenaForAllocation());
}
inline std::string* increaseMapClientsResponse::_internal_mutable_serviceurl() {
  
  return _impl_.serviceurl_.Mutable(GetArenaForAllocation());
}
inline std::string* increaseMapClientsResponse::release_serviceurl() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.increaseMapClientsResponse.serviceURL)
  return _impl_.serviceurl_.Release();
}
inline void increaseMapClientsResponse::set_allocated_serviceurl(std::string* serviceurl) {
  if (serviceurl != nullptr) {
    
  } else {
    
  }
  _impl_.serviceurl_.SetAllocated(serviceurl, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.serviceurl_.IsDefault()) {
    _impl_.serviceurl_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.increaseMapClientsResponse.serviceURL)
}

// sint32 xpcfGrpcReturnValue = 2;
inline void increaseMapClientsResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t increaseMapClientsResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t increaseMapClientsResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.increaseMapClientsResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void increaseMapClientsResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void increaseMapClientsResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.increaseMapClientsResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// decreaseMapClientsRequest

// int32 grpcServerCompressionFormat = 1;
inline void decreaseMapClientsRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t decreaseMapClientsRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t decreaseMapClientsRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.decreaseMapClientsRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void decreaseMapClientsRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void decreaseMapClientsRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.decreaseMapClientsRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void decreaseMapClientsRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& decreaseMapClientsRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.decreaseMapClientsRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void decreaseMapClientsRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.decreaseMapClientsRequest.mapUUID)
}
inline std::string* decreaseMapClientsRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.decreaseMapClientsRequest.mapUUID)
  return _s;
}
inline const std::string& decreaseMapClientsRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void decreaseMapClientsRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* decreaseMapClientsRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* decreaseMapClientsRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.decreaseMapClientsRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void decreaseMapClientsRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.decreaseMapClientsRequest.mapUUID)
}

// -------------------------------------------------------------------

// decreaseMapClientsResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void decreaseMapClientsResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t decreaseMapClientsResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t decreaseMapClientsResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.decreaseMapClientsResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void decreaseMapClientsResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void decreaseMapClientsResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.decreaseMapClientsResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// getMapRequestRequest

// int32 grpcServerCompressionFormat = 1;
inline void getMapRequestRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t getMapRequestRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t getMapRequestRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapRequestRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void getMapRequestRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void getMapRequestRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapRequestRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void getMapRequestRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& getMapRequestRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapRequestRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getMapRequestRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapRequestRequest.mapUUID)
}
inline std::string* getMapRequestRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getMapRequestRequest.mapUUID)
  return _s;
}
inline const std::string& getMapRequestRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void getMapRequestRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* getMapRequestRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* getMapRequestRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getMapRequestRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void getMapRequestRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getMapRequestRequest.mapUUID)
}

// bool withKeyframeImages = 3;
inline void getMapRequestRequest::clear_withkeyframeimages() {
  _impl_.withkeyframeimages_ = false;
}
inline bool getMapRequestRequest::_internal_withkeyframeimages() const {
  return _impl_.withkeyframeimages_;
}
inline bool getMapRequestRequest::withkeyframeimages() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapRequestRequest.withKeyframeImages)
  return _internal_withkeyframeimages();
}
inline void getMapRequestRequest::_internal_set_withkeyframeimages(bool value) {
  
  _impl_.withkeyframeimages_ = value;
}
inline void getMapRequestRequest::set_withkeyframeimages(bool value) {
  _internal_set_withkeyframeimages(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapRequestRequest.withKeyframeImages)
}

// bytes map = 4;
inline void getMapRequestRequest::clear_map() {
  _impl_.map_.ClearToEmpty();
}
inline const std::string& getMapRequestRequest::map() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapRequestRequest.map)
  return _internal_map();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getMapRequestRequest::set_map(ArgT0&& arg0, ArgT... args) {
 
 _impl_.map_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapRequestRequest.map)
}
inline std::string* getMapRequestRequest::mutable_map() {
  std::string* _s = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getMapRequestRequest.map)
  return _s;
}
inline const std::string& getMapRequestRequest::_internal_map() const {
  return _impl_.map_.Get();
}
inline void getMapRequestRequest::_internal_set_map(const std::string& value) {
  
  _impl_.map_.Set(value, GetArenaForAllocation());
}
inline std::string* getMapRequestRequest::_internal_mutable_map() {
  
  return _impl_.map_.Mutable(GetArenaForAllocation());
}
inline std::string* getMapRequestRequest::release_map() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getMapRequestRequest.map)
  return _impl_.map_.Release();
}
inline void getMapRequestRequest::set_allocated_map(std::string* map) {
  if (map != nullptr) {
    
  } else {
    
  }
  _impl_.map_.SetAllocated(map, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_.IsDefault()) {
    _impl_.map_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getMapRequestRequest.map)
}

// -------------------------------------------------------------------

// getMapRequestResponse

// bytes map = 1;
inline void getMapRequestResponse::clear_map() {
  _impl_.map_.ClearToEmpty();
}
inline const std::string& getMapRequestResponse::map() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapRequestResponse.map)
  return _internal_map();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getMapRequestResponse::set_map(ArgT0&& arg0, ArgT... args) {
 
 _impl_.map_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapRequestResponse.map)
}
inline std::string* getMapRequestResponse::mutable_map() {
  std::string* _s = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getMapRequestResponse.map)
  return _s;
}
inline const std::string& getMapRequestResponse::_internal_map() const {
  return _impl_.map_.Get();
}
inline void getMapRequestResponse::_internal_set_map(const std::string& value) {
  
  _impl_.map_.Set(value, GetArenaForAllocation());
}
inline std::string* getMapRequestResponse::_internal_mutable_map() {
  
  return _impl_.map_.Mutable(GetArenaForAllocation());
}
inline std::string* getMapRequestResponse::release_map() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getMapRequestResponse.map)
  return _impl_.map_.Release();
}
inline void getMapRequestResponse::set_allocated_map(std::string* map) {
  if (map != nullptr) {
    
  } else {
    
  }
  _impl_.map_.SetAllocated(map, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.map_.IsDefault()) {
    _impl_.map_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getMapRequestResponse.map)
}

// sint32 xpcfGrpcReturnValue = 2;
inline void getMapRequestResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t getMapRequestResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t getMapRequestResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapRequestResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void getMapRequestResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void getMapRequestResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapRequestResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// setMapRequestRequest

// int32 grpcServerCompressionFormat = 1;
inline void setMapRequestRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t setMapRequestRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t setMapRequestRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.setMapRequestRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void setMapRequestRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void setMapRequestRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.setMapRequestRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void setMapRequestRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& setMapRequestRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.setMapRequestRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void setMapRequestRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.setMapRequestRequest.mapUUID)
}
inline std::string* setMapRequestRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.setMapRequestRequest.mapUUID)
  return _s;
}
inline const std::string& setMapRequestRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void setMapRequestRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* setMapRequestRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* setMapRequestRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.setMapRequestRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void setMapRequestRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.setMapRequestRequest.mapUUID)
}

// bytes mapDatastructure = 3;
inline void setMapRequestRequest::clear_mapdatastructure() {
  _impl_.mapdatastructure_.ClearToEmpty();
}
inline const std::string& setMapRequestRequest::mapdatastructure() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.setMapRequestRequest.mapDatastructure)
  return _internal_mapdatastructure();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void setMapRequestRequest::set_mapdatastructure(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapdatastructure_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.setMapRequestRequest.mapDatastructure)
}
inline std::string* setMapRequestRequest::mutable_mapdatastructure() {
  std::string* _s = _internal_mutable_mapdatastructure();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.setMapRequestRequest.mapDatastructure)
  return _s;
}
inline const std::string& setMapRequestRequest::_internal_mapdatastructure() const {
  return _impl_.mapdatastructure_.Get();
}
inline void setMapRequestRequest::_internal_set_mapdatastructure(const std::string& value) {
  
  _impl_.mapdatastructure_.Set(value, GetArenaForAllocation());
}
inline std::string* setMapRequestRequest::_internal_mutable_mapdatastructure() {
  
  return _impl_.mapdatastructure_.Mutable(GetArenaForAllocation());
}
inline std::string* setMapRequestRequest::release_mapdatastructure() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.setMapRequestRequest.mapDatastructure)
  return _impl_.mapdatastructure_.Release();
}
inline void setMapRequestRequest::set_allocated_mapdatastructure(std::string* mapdatastructure) {
  if (mapdatastructure != nullptr) {
    
  } else {
    
  }
  _impl_.mapdatastructure_.SetAllocated(mapdatastructure, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapdatastructure_.IsDefault()) {
    _impl_.mapdatastructure_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.setMapRequestRequest.mapDatastructure)
}

// -------------------------------------------------------------------

// setMapRequestResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void setMapRequestResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t setMapRequestResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t setMapRequestResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.setMapRequestResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void setMapRequestResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void setMapRequestResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.setMapRequestResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// getPointCloudRequestRequest

// int32 grpcServerCompressionFormat = 1;
inline void getPointCloudRequestRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t getPointCloudRequestRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t getPointCloudRequestRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getPointCloudRequestRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void getPointCloudRequestRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void getPointCloudRequestRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getPointCloudRequestRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void getPointCloudRequestRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& getPointCloudRequestRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getPointCloudRequestRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getPointCloudRequestRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getPointCloudRequestRequest.mapUUID)
}
inline std::string* getPointCloudRequestRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getPointCloudRequestRequest.mapUUID)
  return _s;
}
inline const std::string& getPointCloudRequestRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void getPointCloudRequestRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* getPointCloudRequestRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* getPointCloudRequestRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getPointCloudRequestRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void getPointCloudRequestRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getPointCloudRequestRequest.mapUUID)
}

// bytes pointCloud = 3;
inline void getPointCloudRequestRequest::clear_pointcloud() {
  _impl_.pointcloud_.ClearToEmpty();
}
inline const std::string& getPointCloudRequestRequest::pointcloud() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getPointCloudRequestRequest.pointCloud)
  return _internal_pointcloud();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getPointCloudRequestRequest::set_pointcloud(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pointcloud_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getPointCloudRequestRequest.pointCloud)
}
inline std::string* getPointCloudRequestRequest::mutable_pointcloud() {
  std::string* _s = _internal_mutable_pointcloud();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getPointCloudRequestRequest.pointCloud)
  return _s;
}
inline const std::string& getPointCloudRequestRequest::_internal_pointcloud() const {
  return _impl_.pointcloud_.Get();
}
inline void getPointCloudRequestRequest::_internal_set_pointcloud(const std::string& value) {
  
  _impl_.pointcloud_.Set(value, GetArenaForAllocation());
}
inline std::string* getPointCloudRequestRequest::_internal_mutable_pointcloud() {
  
  return _impl_.pointcloud_.Mutable(GetArenaForAllocation());
}
inline std::string* getPointCloudRequestRequest::release_pointcloud() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getPointCloudRequestRequest.pointCloud)
  return _impl_.pointcloud_.Release();
}
inline void getPointCloudRequestRequest::set_allocated_pointcloud(std::string* pointcloud) {
  if (pointcloud != nullptr) {
    
  } else {
    
  }
  _impl_.pointcloud_.SetAllocated(pointcloud, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pointcloud_.IsDefault()) {
    _impl_.pointcloud_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getPointCloudRequestRequest.pointCloud)
}

// -------------------------------------------------------------------

// getPointCloudRequestResponse

// bytes pointCloud = 1;
inline void getPointCloudRequestResponse::clear_pointcloud() {
  _impl_.pointcloud_.ClearToEmpty();
}
inline const std::string& getPointCloudRequestResponse::pointcloud() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getPointCloudRequestResponse.pointCloud)
  return _internal_pointcloud();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getPointCloudRequestResponse::set_pointcloud(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pointcloud_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getPointCloudRequestResponse.pointCloud)
}
inline std::string* getPointCloudRequestResponse::mutable_pointcloud() {
  std::string* _s = _internal_mutable_pointcloud();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getPointCloudRequestResponse.pointCloud)
  return _s;
}
inline const std::string& getPointCloudRequestResponse::_internal_pointcloud() const {
  return _impl_.pointcloud_.Get();
}
inline void getPointCloudRequestResponse::_internal_set_pointcloud(const std::string& value) {
  
  _impl_.pointcloud_.Set(value, GetArenaForAllocation());
}
inline std::string* getPointCloudRequestResponse::_internal_mutable_pointcloud() {
  
  return _impl_.pointcloud_.Mutable(GetArenaForAllocation());
}
inline std::string* getPointCloudRequestResponse::release_pointcloud() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getPointCloudRequestResponse.pointCloud)
  return _impl_.pointcloud_.Release();
}
inline void getPointCloudRequestResponse::set_allocated_pointcloud(std::string* pointcloud) {
  if (pointcloud != nullptr) {
    
  } else {
    
  }
  _impl_.pointcloud_.SetAllocated(pointcloud, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pointcloud_.IsDefault()) {
    _impl_.pointcloud_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getPointCloudRequestResponse.pointCloud)
}

// sint32 xpcfGrpcReturnValue = 2;
inline void getPointCloudRequestResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t getPointCloudRequestResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t getPointCloudRequestResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getPointCloudRequestResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void getPointCloudRequestResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void getPointCloudRequestResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getPointCloudRequestResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// getMapInfoRequest

// int32 grpcServerCompressionFormat = 1;
inline void getMapInfoRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t getMapInfoRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t getMapInfoRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapInfoRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void getMapInfoRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void getMapInfoRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapInfoRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void getMapInfoRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& getMapInfoRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapInfoRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getMapInfoRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapInfoRequest.mapUUID)
}
inline std::string* getMapInfoRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getMapInfoRequest.mapUUID)
  return _s;
}
inline const std::string& getMapInfoRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void getMapInfoRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* getMapInfoRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* getMapInfoRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getMapInfoRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void getMapInfoRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getMapInfoRequest.mapUUID)
}

// sint32 descriptorType = 3;
inline void getMapInfoRequest::clear_descriptortype() {
  _impl_.descriptortype_ = 0;
}
inline int32_t getMapInfoRequest::_internal_descriptortype() const {
  return _impl_.descriptortype_;
}
inline int32_t getMapInfoRequest::descriptortype() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapInfoRequest.descriptorType)
  return _internal_descriptortype();
}
inline void getMapInfoRequest::_internal_set_descriptortype(int32_t value) {
  
  _impl_.descriptortype_ = value;
}
inline void getMapInfoRequest::set_descriptortype(int32_t value) {
  _internal_set_descriptortype(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapInfoRequest.descriptorType)
}

// uint32 mapSupportedTypes = 4;
inline void getMapInfoRequest::clear_mapsupportedtypes() {
  _impl_.mapsupportedtypes_ = 0u;
}
inline uint32_t getMapInfoRequest::_internal_mapsupportedtypes() const {
  return _impl_.mapsupportedtypes_;
}
inline uint32_t getMapInfoRequest::mapsupportedtypes() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapInfoRequest.mapSupportedTypes)
  return _internal_mapsupportedtypes();
}
inline void getMapInfoRequest::_internal_set_mapsupportedtypes(uint32_t value) {
  
  _impl_.mapsupportedtypes_ = value;
}
inline void getMapInfoRequest::set_mapsupportedtypes(uint32_t value) {
  _internal_set_mapsupportedtypes(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapInfoRequest.mapSupportedTypes)
}

// uint32 dataSize = 5;
inline void getMapInfoRequest::clear_datasize() {
  _impl_.datasize_ = 0u;
}
inline uint32_t getMapInfoRequest::_internal_datasize() const {
  return _impl_.datasize_;
}
inline uint32_t getMapInfoRequest::datasize() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapInfoRequest.dataSize)
  return _internal_datasize();
}
inline void getMapInfoRequest::_internal_set_datasize(uint32_t value) {
  
  _impl_.datasize_ = value;
}
inline void getMapInfoRequest::set_datasize(uint32_t value) {
  _internal_set_datasize(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapInfoRequest.dataSize)
}

// bool areImageSaved = 6;
inline void getMapInfoRequest::clear_areimagesaved() {
  _impl_.areimagesaved_ = false;
}
inline bool getMapInfoRequest::_internal_areimagesaved() const {
  return _impl_.areimagesaved_;
}
inline bool getMapInfoRequest::areimagesaved() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapInfoRequest.areImageSaved)
  return _internal_areimagesaved();
}
inline void getMapInfoRequest::_internal_set_areimagesaved(bool value) {
  
  _impl_.areimagesaved_ = value;
}
inline void getMapInfoRequest::set_areimagesaved(bool value) {
  _internal_set_areimagesaved(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapInfoRequest.areImageSaved)
}

// -------------------------------------------------------------------

// getMapInfoResponse

// sint32 descriptorType = 1;
inline void getMapInfoResponse::clear_descriptortype() {
  _impl_.descriptortype_ = 0;
}
inline int32_t getMapInfoResponse::_internal_descriptortype() const {
  return _impl_.descriptortype_;
}
inline int32_t getMapInfoResponse::descriptortype() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapInfoResponse.descriptorType)
  return _internal_descriptortype();
}
inline void getMapInfoResponse::_internal_set_descriptortype(int32_t value) {
  
  _impl_.descriptortype_ = value;
}
inline void getMapInfoResponse::set_descriptortype(int32_t value) {
  _internal_set_descriptortype(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapInfoResponse.descriptorType)
}

// uint32 mapSupportedTypes = 2;
inline void getMapInfoResponse::clear_mapsupportedtypes() {
  _impl_.mapsupportedtypes_ = 0u;
}
inline uint32_t getMapInfoResponse::_internal_mapsupportedtypes() const {
  return _impl_.mapsupportedtypes_;
}
inline uint32_t getMapInfoResponse::mapsupportedtypes() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapInfoResponse.mapSupportedTypes)
  return _internal_mapsupportedtypes();
}
inline void getMapInfoResponse::_internal_set_mapsupportedtypes(uint32_t value) {
  
  _impl_.mapsupportedtypes_ = value;
}
inline void getMapInfoResponse::set_mapsupportedtypes(uint32_t value) {
  _internal_set_mapsupportedtypes(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapInfoResponse.mapSupportedTypes)
}

// uint32 dataSize = 3;
inline void getMapInfoResponse::clear_datasize() {
  _impl_.datasize_ = 0u;
}
inline uint32_t getMapInfoResponse::_internal_datasize() const {
  return _impl_.datasize_;
}
inline uint32_t getMapInfoResponse::datasize() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapInfoResponse.dataSize)
  return _internal_datasize();
}
inline void getMapInfoResponse::_internal_set_datasize(uint32_t value) {
  
  _impl_.datasize_ = value;
}
inline void getMapInfoResponse::set_datasize(uint32_t value) {
  _internal_set_datasize(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapInfoResponse.dataSize)
}

// bool areImageSaved = 4;
inline void getMapInfoResponse::clear_areimagesaved() {
  _impl_.areimagesaved_ = false;
}
inline bool getMapInfoResponse::_internal_areimagesaved() const {
  return _impl_.areimagesaved_;
}
inline bool getMapInfoResponse::areimagesaved() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapInfoResponse.areImageSaved)
  return _internal_areimagesaved();
}
inline void getMapInfoResponse::_internal_set_areimagesaved(bool value) {
  
  _impl_.areimagesaved_ = value;
}
inline void getMapInfoResponse::set_areimagesaved(bool value) {
  _internal_set_areimagesaved(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapInfoResponse.areImageSaved)
}

// sint32 xpcfGrpcReturnValue = 5;
inline void getMapInfoResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t getMapInfoResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t getMapInfoResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapInfoResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void getMapInfoResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void getMapInfoResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapInfoResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// requestMapProcessingRequest

// int32 grpcServerCompressionFormat = 1;
inline void requestMapProcessingRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t requestMapProcessingRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t requestMapProcessingRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.requestMapProcessingRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void requestMapProcessingRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void requestMapProcessingRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.requestMapProcessingRequest.grpcServerCompressionFormat)
}

// string mapUUID = 2;
inline void requestMapProcessingRequest::clear_mapuuid() {
  _impl_.mapuuid_.ClearToEmpty();
}
inline const std::string& requestMapProcessingRequest::mapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.requestMapProcessingRequest.mapUUID)
  return _internal_mapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void requestMapProcessingRequest::set_mapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.requestMapProcessingRequest.mapUUID)
}
inline std::string* requestMapProcessingRequest::mutable_mapuuid() {
  std::string* _s = _internal_mutable_mapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.requestMapProcessingRequest.mapUUID)
  return _s;
}
inline const std::string& requestMapProcessingRequest::_internal_mapuuid() const {
  return _impl_.mapuuid_.Get();
}
inline void requestMapProcessingRequest::_internal_set_mapuuid(const std::string& value) {
  
  _impl_.mapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* requestMapProcessingRequest::_internal_mutable_mapuuid() {
  
  return _impl_.mapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* requestMapProcessingRequest::release_mapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.requestMapProcessingRequest.mapUUID)
  return _impl_.mapuuid_.Release();
}
inline void requestMapProcessingRequest::set_allocated_mapuuid(std::string* mapuuid) {
  if (mapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.mapuuid_.SetAllocated(mapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapuuid_.IsDefault()) {
    _impl_.mapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.requestMapProcessingRequest.mapUUID)
}

// string resultMapUUID = 3;
inline void requestMapProcessingRequest::clear_resultmapuuid() {
  _impl_.resultmapuuid_.ClearToEmpty();
}
inline const std::string& requestMapProcessingRequest::resultmapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.requestMapProcessingRequest.resultMapUUID)
  return _internal_resultmapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void requestMapProcessingRequest::set_resultmapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resultmapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.requestMapProcessingRequest.resultMapUUID)
}
inline std::string* requestMapProcessingRequest::mutable_resultmapuuid() {
  std::string* _s = _internal_mutable_resultmapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.requestMapProcessingRequest.resultMapUUID)
  return _s;
}
inline const std::string& requestMapProcessingRequest::_internal_resultmapuuid() const {
  return _impl_.resultmapuuid_.Get();
}
inline void requestMapProcessingRequest::_internal_set_resultmapuuid(const std::string& value) {
  
  _impl_.resultmapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* requestMapProcessingRequest::_internal_mutable_resultmapuuid() {
  
  return _impl_.resultmapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* requestMapProcessingRequest::release_resultmapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.requestMapProcessingRequest.resultMapUUID)
  return _impl_.resultmapuuid_.Release();
}
inline void requestMapProcessingRequest::set_allocated_resultmapuuid(std::string* resultmapuuid) {
  if (resultmapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.resultmapuuid_.SetAllocated(resultmapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resultmapuuid_.IsDefault()) {
    _impl_.resultmapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.requestMapProcessingRequest.resultMapUUID)
}

// sint32 processingType = 4;
inline void requestMapProcessingRequest::clear_processingtype() {
  _impl_.processingtype_ = 0;
}
inline int32_t requestMapProcessingRequest::_internal_processingtype() const {
  return _impl_.processingtype_;
}
inline int32_t requestMapProcessingRequest::processingtype() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.requestMapProcessingRequest.processingType)
  return _internal_processingtype();
}
inline void requestMapProcessingRequest::_internal_set_processingtype(int32_t value) {
  
  _impl_.processingtype_ = value;
}
inline void requestMapProcessingRequest::set_processingtype(int32_t value) {
  _internal_set_processingtype(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.requestMapProcessingRequest.processingType)
}

// -------------------------------------------------------------------

// requestMapProcessingResponse

// sint32 xpcfGrpcReturnValue = 1;
inline void requestMapProcessingResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t requestMapProcessingResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t requestMapProcessingResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.requestMapProcessingResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void requestMapProcessingResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void requestMapProcessingResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.requestMapProcessingResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// getMapProcessingStatusRequest

// int32 grpcServerCompressionFormat = 1;
inline void getMapProcessingStatusRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t getMapProcessingStatusRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t getMapProcessingStatusRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingStatusRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void getMapProcessingStatusRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void getMapProcessingStatusRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingStatusRequest.grpcServerCompressionFormat)
}

// string resultMapUUID = 2;
inline void getMapProcessingStatusRequest::clear_resultmapuuid() {
  _impl_.resultmapuuid_.ClearToEmpty();
}
inline const std::string& getMapProcessingStatusRequest::resultmapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingStatusRequest.resultMapUUID)
  return _internal_resultmapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getMapProcessingStatusRequest::set_resultmapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resultmapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingStatusRequest.resultMapUUID)
}
inline std::string* getMapProcessingStatusRequest::mutable_resultmapuuid() {
  std::string* _s = _internal_mutable_resultmapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getMapProcessingStatusRequest.resultMapUUID)
  return _s;
}
inline const std::string& getMapProcessingStatusRequest::_internal_resultmapuuid() const {
  return _impl_.resultmapuuid_.Get();
}
inline void getMapProcessingStatusRequest::_internal_set_resultmapuuid(const std::string& value) {
  
  _impl_.resultmapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* getMapProcessingStatusRequest::_internal_mutable_resultmapuuid() {
  
  return _impl_.resultmapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* getMapProcessingStatusRequest::release_resultmapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getMapProcessingStatusRequest.resultMapUUID)
  return _impl_.resultmapuuid_.Release();
}
inline void getMapProcessingStatusRequest::set_allocated_resultmapuuid(std::string* resultmapuuid) {
  if (resultmapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.resultmapuuid_.SetAllocated(resultmapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resultmapuuid_.IsDefault()) {
    _impl_.resultmapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getMapProcessingStatusRequest.resultMapUUID)
}

// sint32 status = 3;
inline void getMapProcessingStatusRequest::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t getMapProcessingStatusRequest::_internal_status() const {
  return _impl_.status_;
}
inline int32_t getMapProcessingStatusRequest::status() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingStatusRequest.status)
  return _internal_status();
}
inline void getMapProcessingStatusRequest::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void getMapProcessingStatusRequest::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingStatusRequest.status)
}

// float progress = 4;
inline void getMapProcessingStatusRequest::clear_progress() {
  _impl_.progress_ = 0;
}
inline float getMapProcessingStatusRequest::_internal_progress() const {
  return _impl_.progress_;
}
inline float getMapProcessingStatusRequest::progress() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingStatusRequest.progress)
  return _internal_progress();
}
inline void getMapProcessingStatusRequest::_internal_set_progress(float value) {
  
  _impl_.progress_ = value;
}
inline void getMapProcessingStatusRequest::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingStatusRequest.progress)
}

// -------------------------------------------------------------------

// getMapProcessingStatusResponse

// sint32 status = 1;
inline void getMapProcessingStatusResponse::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t getMapProcessingStatusResponse::_internal_status() const {
  return _impl_.status_;
}
inline int32_t getMapProcessingStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingStatusResponse.status)
  return _internal_status();
}
inline void getMapProcessingStatusResponse::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void getMapProcessingStatusResponse::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingStatusResponse.status)
}

// float progress = 2;
inline void getMapProcessingStatusResponse::clear_progress() {
  _impl_.progress_ = 0;
}
inline float getMapProcessingStatusResponse::_internal_progress() const {
  return _impl_.progress_;
}
inline float getMapProcessingStatusResponse::progress() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingStatusResponse.progress)
  return _internal_progress();
}
inline void getMapProcessingStatusResponse::_internal_set_progress(float value) {
  
  _impl_.progress_ = value;
}
inline void getMapProcessingStatusResponse::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingStatusResponse.progress)
}

// sint32 xpcfGrpcReturnValue = 3;
inline void getMapProcessingStatusResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t getMapProcessingStatusResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t getMapProcessingStatusResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingStatusResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void getMapProcessingStatusResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void getMapProcessingStatusResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingStatusResponse.xpcfGrpcReturnValue)
}

// -------------------------------------------------------------------

// getMapProcessingDataRequest

// int32 grpcServerCompressionFormat = 1;
inline void getMapProcessingDataRequest::clear_grpcservercompressionformat() {
  _impl_.grpcservercompressionformat_ = 0;
}
inline int32_t getMapProcessingDataRequest::_internal_grpcservercompressionformat() const {
  return _impl_.grpcservercompressionformat_;
}
inline int32_t getMapProcessingDataRequest::grpcservercompressionformat() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingDataRequest.grpcServerCompressionFormat)
  return _internal_grpcservercompressionformat();
}
inline void getMapProcessingDataRequest::_internal_set_grpcservercompressionformat(int32_t value) {
  
  _impl_.grpcservercompressionformat_ = value;
}
inline void getMapProcessingDataRequest::set_grpcservercompressionformat(int32_t value) {
  _internal_set_grpcservercompressionformat(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingDataRequest.grpcServerCompressionFormat)
}

// string resultMapUUID = 2;
inline void getMapProcessingDataRequest::clear_resultmapuuid() {
  _impl_.resultmapuuid_.ClearToEmpty();
}
inline const std::string& getMapProcessingDataRequest::resultmapuuid() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingDataRequest.resultMapUUID)
  return _internal_resultmapuuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getMapProcessingDataRequest::set_resultmapuuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.resultmapuuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingDataRequest.resultMapUUID)
}
inline std::string* getMapProcessingDataRequest::mutable_resultmapuuid() {
  std::string* _s = _internal_mutable_resultmapuuid();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getMapProcessingDataRequest.resultMapUUID)
  return _s;
}
inline const std::string& getMapProcessingDataRequest::_internal_resultmapuuid() const {
  return _impl_.resultmapuuid_.Get();
}
inline void getMapProcessingDataRequest::_internal_set_resultmapuuid(const std::string& value) {
  
  _impl_.resultmapuuid_.Set(value, GetArenaForAllocation());
}
inline std::string* getMapProcessingDataRequest::_internal_mutable_resultmapuuid() {
  
  return _impl_.resultmapuuid_.Mutable(GetArenaForAllocation());
}
inline std::string* getMapProcessingDataRequest::release_resultmapuuid() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getMapProcessingDataRequest.resultMapUUID)
  return _impl_.resultmapuuid_.Release();
}
inline void getMapProcessingDataRequest::set_allocated_resultmapuuid(std::string* resultmapuuid) {
  if (resultmapuuid != nullptr) {
    
  } else {
    
  }
  _impl_.resultmapuuid_.SetAllocated(resultmapuuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.resultmapuuid_.IsDefault()) {
    _impl_.resultmapuuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getMapProcessingDataRequest.resultMapUUID)
}

// bytes pointCloud = 3;
inline void getMapProcessingDataRequest::clear_pointcloud() {
  _impl_.pointcloud_.ClearToEmpty();
}
inline const std::string& getMapProcessingDataRequest::pointcloud() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingDataRequest.pointCloud)
  return _internal_pointcloud();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getMapProcessingDataRequest::set_pointcloud(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pointcloud_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingDataRequest.pointCloud)
}
inline std::string* getMapProcessingDataRequest::mutable_pointcloud() {
  std::string* _s = _internal_mutable_pointcloud();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getMapProcessingDataRequest.pointCloud)
  return _s;
}
inline const std::string& getMapProcessingDataRequest::_internal_pointcloud() const {
  return _impl_.pointcloud_.Get();
}
inline void getMapProcessingDataRequest::_internal_set_pointcloud(const std::string& value) {
  
  _impl_.pointcloud_.Set(value, GetArenaForAllocation());
}
inline std::string* getMapProcessingDataRequest::_internal_mutable_pointcloud() {
  
  return _impl_.pointcloud_.Mutable(GetArenaForAllocation());
}
inline std::string* getMapProcessingDataRequest::release_pointcloud() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getMapProcessingDataRequest.pointCloud)
  return _impl_.pointcloud_.Release();
}
inline void getMapProcessingDataRequest::set_allocated_pointcloud(std::string* pointcloud) {
  if (pointcloud != nullptr) {
    
  } else {
    
  }
  _impl_.pointcloud_.SetAllocated(pointcloud, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pointcloud_.IsDefault()) {
    _impl_.pointcloud_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getMapProcessingDataRequest.pointCloud)
}

// bytes keyframePoses = 4;
inline void getMapProcessingDataRequest::clear_keyframeposes() {
  _impl_.keyframeposes_.ClearToEmpty();
}
inline const std::string& getMapProcessingDataRequest::keyframeposes() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingDataRequest.keyframePoses)
  return _internal_keyframeposes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getMapProcessingDataRequest::set_keyframeposes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.keyframeposes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingDataRequest.keyframePoses)
}
inline std::string* getMapProcessingDataRequest::mutable_keyframeposes() {
  std::string* _s = _internal_mutable_keyframeposes();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getMapProcessingDataRequest.keyframePoses)
  return _s;
}
inline const std::string& getMapProcessingDataRequest::_internal_keyframeposes() const {
  return _impl_.keyframeposes_.Get();
}
inline void getMapProcessingDataRequest::_internal_set_keyframeposes(const std::string& value) {
  
  _impl_.keyframeposes_.Set(value, GetArenaForAllocation());
}
inline std::string* getMapProcessingDataRequest::_internal_mutable_keyframeposes() {
  
  return _impl_.keyframeposes_.Mutable(GetArenaForAllocation());
}
inline std::string* getMapProcessingDataRequest::release_keyframeposes() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getMapProcessingDataRequest.keyframePoses)
  return _impl_.keyframeposes_.Release();
}
inline void getMapProcessingDataRequest::set_allocated_keyframeposes(std::string* keyframeposes) {
  if (keyframeposes != nullptr) {
    
  } else {
    
  }
  _impl_.keyframeposes_.SetAllocated(keyframeposes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.keyframeposes_.IsDefault()) {
    _impl_.keyframeposes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getMapProcessingDataRequest.keyframePoses)
}

// -------------------------------------------------------------------

// getMapProcessingDataResponse

// bytes pointCloud = 1;
inline void getMapProcessingDataResponse::clear_pointcloud() {
  _impl_.pointcloud_.ClearToEmpty();
}
inline const std::string& getMapProcessingDataResponse::pointcloud() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingDataResponse.pointCloud)
  return _internal_pointcloud();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getMapProcessingDataResponse::set_pointcloud(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pointcloud_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingDataResponse.pointCloud)
}
inline std::string* getMapProcessingDataResponse::mutable_pointcloud() {
  std::string* _s = _internal_mutable_pointcloud();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getMapProcessingDataResponse.pointCloud)
  return _s;
}
inline const std::string& getMapProcessingDataResponse::_internal_pointcloud() const {
  return _impl_.pointcloud_.Get();
}
inline void getMapProcessingDataResponse::_internal_set_pointcloud(const std::string& value) {
  
  _impl_.pointcloud_.Set(value, GetArenaForAllocation());
}
inline std::string* getMapProcessingDataResponse::_internal_mutable_pointcloud() {
  
  return _impl_.pointcloud_.Mutable(GetArenaForAllocation());
}
inline std::string* getMapProcessingDataResponse::release_pointcloud() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getMapProcessingDataResponse.pointCloud)
  return _impl_.pointcloud_.Release();
}
inline void getMapProcessingDataResponse::set_allocated_pointcloud(std::string* pointcloud) {
  if (pointcloud != nullptr) {
    
  } else {
    
  }
  _impl_.pointcloud_.SetAllocated(pointcloud, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pointcloud_.IsDefault()) {
    _impl_.pointcloud_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getMapProcessingDataResponse.pointCloud)
}

// bytes keyframePoses = 2;
inline void getMapProcessingDataResponse::clear_keyframeposes() {
  _impl_.keyframeposes_.ClearToEmpty();
}
inline const std::string& getMapProcessingDataResponse::keyframeposes() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingDataResponse.keyframePoses)
  return _internal_keyframeposes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void getMapProcessingDataResponse::set_keyframeposes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.keyframeposes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingDataResponse.keyframePoses)
}
inline std::string* getMapProcessingDataResponse::mutable_keyframeposes() {
  std::string* _s = _internal_mutable_keyframeposes();
  // @@protoc_insertion_point(field_mutable:grpcIMapsManager.getMapProcessingDataResponse.keyframePoses)
  return _s;
}
inline const std::string& getMapProcessingDataResponse::_internal_keyframeposes() const {
  return _impl_.keyframeposes_.Get();
}
inline void getMapProcessingDataResponse::_internal_set_keyframeposes(const std::string& value) {
  
  _impl_.keyframeposes_.Set(value, GetArenaForAllocation());
}
inline std::string* getMapProcessingDataResponse::_internal_mutable_keyframeposes() {
  
  return _impl_.keyframeposes_.Mutable(GetArenaForAllocation());
}
inline std::string* getMapProcessingDataResponse::release_keyframeposes() {
  // @@protoc_insertion_point(field_release:grpcIMapsManager.getMapProcessingDataResponse.keyframePoses)
  return _impl_.keyframeposes_.Release();
}
inline void getMapProcessingDataResponse::set_allocated_keyframeposes(std::string* keyframeposes) {
  if (keyframeposes != nullptr) {
    
  } else {
    
  }
  _impl_.keyframeposes_.SetAllocated(keyframeposes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.keyframeposes_.IsDefault()) {
    _impl_.keyframeposes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:grpcIMapsManager.getMapProcessingDataResponse.keyframePoses)
}

// sint32 xpcfGrpcReturnValue = 3;
inline void getMapProcessingDataResponse::clear_xpcfgrpcreturnvalue() {
  _impl_.xpcfgrpcreturnvalue_ = 0;
}
inline int32_t getMapProcessingDataResponse::_internal_xpcfgrpcreturnvalue() const {
  return _impl_.xpcfgrpcreturnvalue_;
}
inline int32_t getMapProcessingDataResponse::xpcfgrpcreturnvalue() const {
  // @@protoc_insertion_point(field_get:grpcIMapsManager.getMapProcessingDataResponse.xpcfGrpcReturnValue)
  return _internal_xpcfgrpcreturnvalue();
}
inline void getMapProcessingDataResponse::_internal_set_xpcfgrpcreturnvalue(int32_t value) {
  
  _impl_.xpcfgrpcreturnvalue_ = value;
}
inline void getMapProcessingDataResponse::set_xpcfgrpcreturnvalue(int32_t value) {
  _internal_set_xpcfgrpcreturnvalue(value);
  // @@protoc_insertion_point(field_set:grpcIMapsManager.getMapProcessingDataResponse.xpcfGrpcReturnValue)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grpcIMapsManager

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_grpcIMapsManagerService_2eproto
